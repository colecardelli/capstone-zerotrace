
'''

# ZeroTrace — Advanced Network Scanner                              #Works

import os
import sys
import re
import time
import socket
import shutil
import ctypes
import platform
import subprocess
import ipaddress
from datetime import datetime
from collections import Counter, defaultdict
from concurrent.futures import ThreadPoolExecutor, as_completed, TimeoutError

# Third-party libs
try:
    import nmap
    import scapy.all as scapy
    import openpyxl
    from rich.console import Console
    from rich.table import Table
    from rich.progress import Progress, SpinnerColumn, BarColumn, TimeRemainingColumn
except Exception as exc:
    print("Missing library:", exc)
    print("Install: pip install python-nmap scapy openpyxl rich")
    sys.exit(1)

try:
    import requests
except Exception:
    requests = None

console = Console()

# ----------------------
# Config
# ----------------------
CONFIG = {
    "sniff_seconds": 20,
    "excel_output": "zerotrace_report.xlsx",
    "device_processing_timeout": 14,
    "device_thread_workers": 18,
    "scan_thread_workers": 18,
    "ping_count": 4,
    # local OUI CSV file (optional). Format: OUI,Vendor per line (OUI may be 001A11 or 00:1A:11)
    "local_oui_file": "oui.csv",
}

# Minimal builtin OUI map as fallback
OUI_VENDOR_MAP = {
    "B8:27:EB": "Raspberry Pi Foundation",
    "DC:A6:32": "Amazon Technologies",
    "AC:63:BE": "Amazon Echo",
    "3C:5A:B4": "Wyze Labs",
    "F4:F5:D8": "Google Nest",
    "D0:73:D5": "Google Smart Hub",
    "00:1A:11": "Philips Hue",
    "F0:27:2D": "TP-Link Technologies",
    "60:01:94": "Xiaomi Communications",
    "28:6D:97": "Samsung Electronics",
    "00:16:6C": "Sony Corporation",
    "F0:18:98": "Apple, Inc."
}

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------
def is_admin():
    try:
        return os.getuid() == 0
    except AttributeError:
        try:
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        except Exception:
            return False

def load_local_oui(path: str):
    """Load an optional local OUI CSV to extend matching; populates OUI_VENDOR_MAP."""
    if not os.path.isfile(path):
        return
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as fh:
            for line in fh:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                parts = [p.strip() for p in line.split(",", 1)]
                if len(parts) == 2:
                    oui_raw, vendor = parts
                    oui = normalize_oui(oui_raw)
                    if oui:
                        OUI_VENDOR_MAP[oui] = vendor
    except Exception:
        pass

def normalize_oui(oui_raw: str) -> str | None:
    """Return normalized colon-separated OUI (AA:BB:CC) or 6 hex chars (AABBCC) for lookups."""
    if not oui_raw:
        return None
    s = re.sub(r"[^0-9A-Fa-f]", "", oui_raw).upper()
    if len(s) < 6:
        return None
    s6 = s[:6]
    # return both forms: 'AABBCC' and 'AA:BB:CC' checking handles both
    return ":".join([s6[i:i+2] for i in range(0, 6, 2)])

def mac_vendor_lookup(mac: str) -> str:
    """Improved vendor lookup: local file, builtin map, then API fallback (best-effort)."""
    if not mac:
        return "Unknown Vendor"
    m = re.sub(r"[^0-9A-Fa-f]", "", mac).upper()
    if len(m) < 6:
        return "Unknown Vendor"
    oui6 = m[:6]
    prefix = ":".join([oui6[i:i+2] for i in range(0, 6, 2)])
    # check map keyed by 'AA:BB:CC' or 'AABBCC'
    vendor = OUI_VENDOR_MAP.get(prefix) or OUI_VENDOR_MAP.get(oui6)
    if vendor:
        return vendor
    # fallback API if available
    if requests:
        try:
            r = requests.get(f"https://api.macvendors.com/{mac}", timeout=4)
            if r.status_code == 200 and r.text.strip():
                return r.text.strip()
        except Exception:
            pass
    return "Unknown Vendor"

# load optional local OUI file at startup
load_local_oui(CONFIG.get("local_oui_file"))

def get_local_ip():
    s = None
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        return s.getsockname()[0]
    except Exception:
        return None
    finally:
        if s:
            s.close()

# ----------------------
# Wi-Fi helpers (Windows)
# ----------------------
def get_wifi_ssid():
    try:
        out = subprocess.check_output("netsh wlan show interfaces", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL, timeout=3)
        m = re.search(r"^\s*SSID\s*:\s(.+)$", out, re.I | re.M)
        if m:
            return m.group(1).strip()
    except Exception:
        pass
    return None

def list_access_points():
    aps = []
    try:
        out = subprocess.check_output("netsh wlan show networks mode=bssid", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL, timeout=5)
        ssid = None
        for line in out.splitlines():
            line = line.strip()
            if line.startswith("SSID"):
                p = line.split(":",1)
                if len(p) == 2:
                    ssid = p[1].strip()
            elif line.startswith("BSSID"):
                bssid = line.split(":",1)[1].strip()
            elif line.startswith("Signal"):
                signal = line.split(":",1)[1].strip()
                if ssid and bssid:
                    aps.append({"ssid": ssid, "bssid": bssid, "signal": signal})
    except Exception:
        pass
    return aps

def current_wifi_info():
    try:
        out = subprocess.check_output("netsh wlan show interfaces", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL, timeout=3)
        ssid_m = re.search(r"^\s*SSID\s*:\s(.+)$", out, re.I | re.M)
        bssid_m = re.search(r"^\s*BSSID\s*:\s(.+)$", out, re.I | re.M)
        rate_m = re.search(r"^\s*Receive rate \(Mbps\)\s*:\s(.+)$", out, re.I | re.M)
        sig_m = re.search(r"^\s*Signal\s*:\s(.+)$", out, re.I | re.M)
        return {
            "ssid": ssid_m.group(1).strip() if ssid_m else None,
            "bssid": bssid_m.group(1).strip() if bssid_m else None,
            "rate": rate_m.group(1).strip() if rate_m else None,
            "signal": sig_m.group(1).strip() if sig_m else None,
        }
    except Exception:
        return {}

# ----------------------
# Discovery: arp, nmap, both
# ----------------------
def arp_discover(network_cidr):
    console.print(f"[cyan]Running ARP discovery on {network_cidr}...[/cyan]")
    try:
        arp_request = scapy.ARP(pdst=network_cidr)
        broadcast = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
        packet = broadcast/arp_request
        answered = scapy.srp(packet, timeout=2, verbose=False)[0]
        devices = []
        for _, r in answered:
            devices.append({"ip": r.psrc, "mac": (r.hwsrc or "").upper(), "info": None})
        console.print(f"[green]ARP discovered {len(devices)} devices[/green]")
        return devices
    except Exception as e:
        console.print(f"[yellow]ARP discovery failed: {e}[/yellow]")
        return []

def nmap_discover(network_cidr):
    nm = nmap.PortScanner()
    devices = []
    if not shutil.which("nmap"):
        console.print("[yellow]nmap binary not found — falling back to ARP[/yellow]")
        return arp_discover(network_cidr)
    try:
        console.print(f"[cyan]Running nmap -sn {network_cidr}...[/cyan]")
        nm.scan(hosts=network_cidr, arguments="-sn")
        for host in nm.all_hosts():
            try:
                mac = nm[host]['addresses'].get('mac','').upper()
            except Exception:
                mac = ""
            devices.append({"ip": host, "mac": mac, "info": nm[host]})
        console.print(f"[green]Nmap discovered {len(devices)} hosts[/green]")
        return devices
    except Exception as e:
        console.print(f"[yellow]nmap discovery failed: {e} — falling back to ARP[/yellow]")
        return arp_discover(network_cidr)

def combined_discover(network_cidr):
    """Run both ARP and Nmap discovery and merge results (prefer ARP macs)."""
    arp_list = arp_discover(network_cidr)
    nmap_list = nmap_discover(network_cidr)
    merged = {}
    # take all from nmap_list first
    for d in nmap_list:
        ip = d.get("ip")
        if not ip:
            continue
        merged[ip] = {"ip": ip, "mac": d.get("mac","").upper(), "info": d.get("info")}
    # overlay arp mac addresses (prefer ARP mac if exists)
    for d in arp_list:
        ip = d.get("ip")
        if not ip:
            continue
        if ip in merged:
            # prefer ARP-provided MAC
            if d.get("mac"):
                merged[ip]["mac"] = d.get("mac").upper()
        else:
            merged[ip] = {"ip": ip, "mac": d.get("mac","").upper(), "info": None}
    devices = list(merged.values())
    console.print(f"[green]Combined discovery found {len(devices)} unique IPs[/green]")
    return devices

# ----------------------
# Nmap scan (per-host) - returns python-nmap host dict or None
# ----------------------
def nmap_scan_host(ip, mode="quick", timeout=15):
    try:
        nm = nmap.PortScanner()
    except Exception:
        return None
    # choose args
    args = "-sS -T4 --top-ports 20"
    if mode == "deep":
        args = "-sS -sV -O --top-ports 100 --osscan-guess --script vuln"
    try:
        nm.scan(hosts=ip, arguments=args, timeout=timeout)
        if ip in nm.all_hosts():
            return nm[ip]
    except Exception:
        return None
    return None

# ----------------------
# Ping helper
# ----------------------
def ping_device(ip, count=None):
    if count is None:
        count = CONFIG.get("ping_count", 4)
    system = platform.system().lower()
    if system == "windows":
        cmd = ["ping", "-n", str(count), ip]
    else:
        cmd = ["ping", "-c", str(count), ip]
    try:
        out = subprocess.check_output(cmd, universal_newlines=True, stderr=subprocess.DEVNULL, timeout=(count*3 + 5))
    except Exception:
        return None, None
    latency = None
    loss = None
    if system == "windows":
        m_avg = re.search(r"Average = (\d+)ms", out)
        m_loss = re.search(r"(\d+)%\s*loss", out, re.I) or re.search(r"Lost = \d+,.*Lost = \d+", out)
        if m_avg:
            latency = float(m_avg.group(1))
        if m_loss:
            try:
                loss = float(m_loss.group(1))
            except Exception:
                loss = None
    else:
        m_avg = re.search(r"rtt [\w/]+ = [\d\.]+/([\d\.]+)/", out)
        m_loss = re.search(r"(\d+)% packet loss", out)
        if m_avg:
            latency = float(m_avg.group(1))
        if m_loss:
            loss = float(m_loss.group(1))
    return latency, loss

# ----------------------
# Device role inference
# ----------------------
def detect_device_role(device):
    vendor = (device.get("vendor") or "").lower()
    os_guess = (device.get("os") or "").lower()
    open_ports = device.get("open_ports") or ""
    ports = set()
    for p in re.findall(r"\d+", str(open_ports)):
        try:
            ports.add(int(p))
        except Exception:
            pass
    # heuristics
    if 554 in ports or 8554 in ports or "camera" in vendor or "hikvision" in vendor or "dahua" in vendor:
        return "IP Camera / Surveillance"
    if 9100 in ports:
        return "Printer"
    if 3389 in ports:
        return "Windows Remote Desktop"
    if 22 in ports and 80 not in ports and 443 not in ports:
        if "raspberry" in vendor or "raspberry" in os_guess:
            return "Raspberry Pi / Embedded"
        return "SSH Host (Linux/Embedded)"
    if 80 in ports or 443 in ports:
        if "router" in os_guess or device.get("ip","").endswith(".1"):
            return "Router / Gateway"
        if "nas" in os_guess or "synology" in vendor or "qnap" in vendor:
            return "NAS / File Server"
        return "Web Interface Device"
    if "iphone" in os_guess or "ios" in os_guess or "apple" in vendor:
        return "Apple Mobile (iPhone/iPad)"
    if "android" in os_guess or "samsung" in vendor:
        return "Android Mobile"
    if "windows" in os_guess or "microsoft" in vendor:
        return "Windows Desktop/Laptop"
    return "Generic Device"

# ----------------------
# Enrichment
# ----------------------
def enrich_device(device, mode="quick"):
    ip = device.get("ip")
    if not ip:
        return device
    mac = (device.get("mac") or "").upper()
    # vendor
    device["vendor"] = mac_vendor_lookup(mac)
    # nmap per-host
    ndata = None
    if shutil.which("nmap"):
        ndata = nmap_scan_host(ip, mode=mode, timeout=CONFIG["device_processing_timeout"])
    # parse nmap results
    if ndata:
        # OS guess
        os_guess = "Unknown"
        try:
            if "osmatch" in ndata and ndata["osmatch"]:
                os_guess = ndata["osmatch"][0].get("name","Unknown")
            elif "osclass" in ndata and ndata["osclass"]:
                os_guess = ndata["osclass"][0].get("osfamily","Unknown")
        except Exception:
            os_guess = "Unknown"
        device["os"] = os_guess
        # open ports
        try:
            tcp = ndata.get("tcp", {}) or {}
            open_ports = [int(p) for p,info in tcp.items() if (info.get("state","") if isinstance(info, dict) else getattr(info,"state","")).lower() == "open"]
            device["open_ports"] = ", ".join(str(p) for p in sorted(open_ports)) if open_ports else "None"
        except Exception:
            device["open_ports"] = "Unknown"
        # vulnerabilities: hostscript or scripts
        vulns = []
        try:
            hostscript = ndata.get("hostscript", []) or []
            for s in hostscript:
                out = s.get("output") if isinstance(s, dict) else None
                if out:
                    vulns.append(out.strip())
            tcp = ndata.get("tcp", {}) or {}
            for p,info in tcp.items():
                scripts = info.get("script", {}) if isinstance(info, dict) else {}
                if isinstance(scripts, dict):
                    for sid, st in scripts.items():
                        vulns.append(f"Port {p}: {sid} - {st}")
        except Exception:
            pass
        device["vulnerabilities"] = "; ".join(vulns) if vulns else "None found"
    else:
        device.setdefault("os", "Unknown")
        device.setdefault("open_ports", "Unknown")
        device.setdefault("vulnerabilities", "Unknown or not scanned")
    # ping
    lat, loss = ping_device(ip, count=CONFIG.get("ping_count",4))
    device["latency_ms"] = f"{lat:.1f}" if lat is not None else "N/A"
    device["packet_loss_pct"] = f"{loss:.0f}%" if loss is not None else "N/A"
    # hostname
    try:
        device["hostname"] = socket.getfqdn(ip) or ip
    except Exception:
        device["hostname"] = ip
    # role
    device["role"] = detect_device_role(device)
    now = datetime.utcnow().isoformat() + "Z"
    device.setdefault("discovered_at", now)
    device["last_seen_at"] = now
    return device

def enrich_devices(devices, mode="quick"):
    total = len(devices)
    if total == 0:
        return []
    console.print(f"[cyan]Enriching {total} devices (workers={CONFIG['device_thread_workers']})[/cyan]")
    enriched = []
    with Progress(SpinnerColumn(), "[progress.description]{task.description}", BarColumn(), "{task.completed}/{task.total}", TimeRemainingColumn(), console=console) as progress:
        task = progress.add_task("Enriching...", total=total)
        with ThreadPoolExecutor(max_workers=CONFIG["device_thread_workers"]) as exe:
            futures = {exe.submit(enrich_device, d, mode): d for d in devices}
            for fut in as_completed(futures):
                try:
                    dev = fut.result(timeout=CONFIG["device_processing_timeout"])
                except TimeoutError:
                    d = futures[fut]
                    console.print(f"[red]Timeout enriching {d.get('ip')}[/red]")
                    d.setdefault("os", "Timeout")
                    d.setdefault("open_ports", "Timeout")
                    d.setdefault("vulnerabilities", "Timeout")
                    d.setdefault("latency_ms", "N/A")
                    d.setdefault("packet_loss_pct", "N/A")
                    d.setdefault("role", "Unknown")
                    dev = d
                except Exception as e:
                    d = futures[fut]
                    console.print(f"[red]Error enriching {d.get('ip')}: {e}[/red]")
                    dev = d
                enriched.append(dev)
                progress.update(task, advance=1)
    return enriched

# ----------------------
# Capture traffic
# ----------------------
def capture_traffic(duration=20):
    console.print(f"[cyan]Sniffing traffic for {duration}s to detect communications (optional)...[/cyan]")
    try:
        pkts = scapy.sniff(timeout=duration)
    except Exception as e:
        console.print(f"[yellow]Sniffer failed: {e}[/yellow]")
        return {}
    comms = defaultdict(set)
    for pkt in pkts:
        if pkt.haslayer(scapy.IP):
            try:
                s = pkt[scapy.IP].src
                d = pkt[scapy.IP].dst
                comms[s].add(d)
                comms[d].add(s)
            except Exception:
                pass
    return comms

# ----------------------
# Report
# ----------------------
def generate_report(devices, communications, excel_path):
    headers = [
        "IP","MAC","Vendor","Hostname","OS","Role",
        "Open Ports","Vulnerabilities","Latency (ms)","Packet Loss",
        "Discovered At","Last Seen","External Comms"
    ]
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Scan Report"
    ws.append(headers)
    tbl = Table(title="ZeroTrace Scan Report", show_lines=False)
    for h in headers:
        tbl.add_column(h)
    for d in devices:
        ip = d.get("ip","")
        mac = d.get("mac","")
        vendor = d.get("vendor","")
        hostname = d.get("hostname", ip)
        osg = d.get("os","Unknown")
        role = d.get("role","Generic Device")
        openp = d.get("open_ports","")
        vulns = d.get("vulnerabilities","")
        lat = d.get("latency_ms","")
        loss = d.get("packet_loss_pct","")
        disc = d.get("discovered_at","")
        last = d.get("last_seen_at","")
        ext = ", ".join(sorted(communications.get(ip, []))) if communications and ip in communications else "None observed"
        ws.append([ip,mac,vendor,hostname,osg,role,openp,vulns,lat,loss,disc,last,ext])
        tbl.add_row(str(ip), str(mac), str(vendor), str(hostname), str(osg), str(role), str(openp), str(vulns), str(lat), str(loss), str(disc), str(last), str(ext))
    # network context
    ws.append([])
    try:
        out = subprocess.check_output("netsh interface ip show addresses", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL)
        m = re.search(r"Default Gateway:\s*([0-9.]+)", out)
        if m:
            ws.append(["Default Gateway", m.group(1)])
    except Exception:
        pass
    # AP sheet
    aps = list_access_points()
    curr = current_wifi_info()
    ws_ap = wb.create_sheet("Access Points")
    ws_ap.append(["SSID","BSSID","Signal","Type","Current"])
    ssid_counts = Counter([a.get("ssid") for a in aps if a.get("ssid")])
    for a in aps:
        typ = "Mesh/Extender" if ssid_counts[a.get("ssid")] > 1 else "Primary"
        is_cur = ""
        if curr and curr.get("bssid") and a.get("bssid") and a.get("bssid").lower() == curr.get("bssid","").lower():
            is_cur = "Yes"
        ws_ap.append([a.get("ssid"), a.get("bssid"), a.get("signal"), typ, is_cur])
    ws_ap.append([])
    ws_ap.append(["Current Connection","SSID","BSSID","Rate (Mbps)","Signal"])
    ws_ap.append(["", curr.get("ssid",""), curr.get("bssid",""), curr.get("rate",""), curr.get("signal","")])
    console.print(tbl)
    try:
        wb.save(excel_path)
        console.print(f"[green]✔ Report saved to {os.path.abspath(excel_path)}[/green]")
    except Exception as e:
        console.print(f"[red]Failed to save Excel: {e}[/red]")

# ----------------------
# Orchestration
# ----------------------
def scan_network(mode="quick", discovery_method="nmap"):
    local_ip = get_local_ip()
    if not local_ip:
        console.print("[red]Couldn't determine local IP - aborting[/red]")
        return []
    network_cidr = str(ipaddress.ip_network(f"{local_ip}/24", strict=False))
    console.print(f"[blue]Discovery range: {network_cidr}[/blue]")
    if discovery_method == "arp":
        discovered = arp_discover(network_cidr)
    elif discovery_method == "nmap":
        discovered = nmap_discover(network_cidr)
    else:
        discovered = combined_discover(network_cidr)
    # vendor quick summary
    vendors = [mac_vendor_lookup(d.get("mac")) for d in discovered]
    counts = Counter(vendors)
    sample = ", ".join(list(counts.keys())[:8])
    console.print(f"[green]Vendors detected ({len(counts)}): {sample}[/green]")
    console.print(f"[cyan]Devices discovered: {len(discovered)}[/cyan]")
    return discovered

def main():
    console.print("[bold cyan]ZeroTrace — ARP + Nmap Combined Scanner[/bold cyan]")
    if is_admin():
        console.print("[green]✔ Running as Administrator[/green]")
    else:
        console.print("[yellow]⚠ Not running as Administrator — deep OS/vuln detection may be limited[/yellow]")
    conn_type = "Wi-Fi" if get_wifi_ssid() else "Ethernet"
    ssid = get_wifi_ssid() if conn_type == "Wi-Fi" else None
    console.print(f"[blue]Connection type:[/] {conn_type}")
    if ssid:
        console.print(f"[blue]Connected SSID:[/] {ssid}")
    # discovery mode: arp, nmap, both
    disc = console.input("[cyan]Discovery method ([b]nmap[/b]/[b]arp[/b]/[b]both[/b]) [both]: ").strip().lower() or "both"
    if disc not in ("nmap","arp","both"):
        disc = "both"
    # quick or deep
    mode = console.input("[cyan]Scan mode ([b]quick[/b]/[b]deep[/b]) [quick]: ").strip().lower() or "quick"
    if mode not in ("quick","deep"):
        mode = "quick"
    discovered = scan_network(mode=mode, discovery_method=disc)
    if not discovered:
        console.print("[red]No devices discovered — exiting[/red]")
        return
    # optional short sniff for comms
    communications = {}
    try:
        communications = capture_traffic(CONFIG.get("sniff_seconds", 20))
    except Exception:
        communications = {}
    enriched = enrich_devices(discovered, mode=mode)
    generate_report(enriched, communications, CONFIG.get("excel_output"))
    console.print("[green]Done.[/green]")

if __name__ == "__main__":
    main()


'''



#                                                                     --------------------------------------------------------------------------------                                                                           




'''
import os
import sys
import re
import time
import socket
import shutil
import ctypes
import platform
import subprocess
import ipaddress
from datetime import datetime
from collections import Counter, defaultdict
from concurrent.futures import ThreadPoolExecutor, as_completed, TimeoutError

# Third-party libs
try:
    import nmap
    import scapy.all as scapy
    import openpyxl
    from rich.console import Console
    from rich.table import Table
    from rich.progress import Progress, SpinnerColumn, BarColumn, TimeRemainingColumn
except Exception as exc:
    print("Missing library:", exc)
    print("Install: pip install python-nmap scapy openpyxl rich")
    sys.exit(1)

try:
    import requests
except Exception:
    requests = None

console = Console()

# ----------------------
# Config
# ----------------------
CONFIG = {
    "sniff_seconds": 20,
    "excel_output": "zerotrace_report.xlsx",
    "device_processing_timeout": 14,
    "device_thread_workers": 18,
    "scan_thread_workers": 18,
    "ping_count": 4,
    # local OUI CSV file (optional). Format: OUI,Vendor per line (OUI may be 001A11 or 00:1A:11)
    "local_oui_file": "oui.csv",
}

# Minimal builtin OUI map as fallback
OUI_VENDOR_MAP = {
    "B8:27:EB": "Raspberry Pi Foundation",
    "DC:A6:32": "Amazon Technologies",
    "AC:63:BE": "Amazon Echo",
    "3C:5A:B4": "Wyze Labs",
    "F4:F5:D8": "Google Nest",
    "D0:73:D5": "Google Smart Hub",
    "00:1A:11": "Philips Hue",
    "F0:27:2D": "TP-Link Technologies",
    "60:01:94": "Xiaomi Communications",
    "28:6D:97": "Samsung Electronics",
    "00:16:6C": "Sony Corporation",
    "F0:18:98": "Apple, Inc."
}

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------
def is_admin():
    try:
        return os.getuid() == 0
    except AttributeError:
        try:
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        except Exception:
            return False

def load_local_oui(path: str):
    """Load an optional local OUI CSV to extend matching; populates OUI_VENDOR_MAP."""
    if not os.path.isfile(path):
        return
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as fh:
            for line in fh:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                parts = [p.strip() for p in line.split(",", 1)]
                if len(parts) == 2:
                    oui_raw, vendor = parts
                    oui = normalize_oui(oui_raw)
                    if oui:
                        OUI_VENDOR_MAP[oui] = vendor
    except Exception:
        pass

def normalize_oui(oui_raw: str) -> str | None:
    """Return normalized colon-separated OUI (AA:BB:CC) or 6 hex chars (AABBCC) for lookups."""
    if not oui_raw:
        return None
    s = re.sub(r"[^0-9A-Fa-f]", "", oui_raw).upper()
    if len(s) < 6:
        return None
    s6 = s[:6]
    # return both forms: 'AABBCC' and 'AA:BB:CC' checking handles both
    return ":".join([s6[i:i+2] for i in range(0, 6, 2)])

def mac_vendor_lookup(mac: str) -> str:
    """Improved vendor lookup: local file, builtin map, then API fallback (best-effort)."""
    if not mac:
        return "Unknown Vendor"
    m = re.sub(r"[^0-9A-Fa-f]", "", mac).upper()
    if len(m) < 6:
        return "Unknown Vendor"
    oui6 = m[:6]
    prefix = ":".join([oui6[i:i+2] for i in range(0, 6, 2)])
    # check map keyed by 'AA:BB:CC' or 'AABBCC'
    vendor = OUI_VENDOR_MAP.get(prefix) or OUI_VENDOR_MAP.get(oui6)
    if vendor:
        return vendor
    # fallback API if available
    if requests:
        try:
            r = requests.get(f"https://api.macvendors.com/{mac}", timeout=4)
            if r.status_code == 200 and r.text.strip():
                return r.text.strip()
        except Exception:
            pass
    return "Unknown Vendor"

# load optional local OUI file at startup
load_local_oui(CONFIG.get("local_oui_file"))

def get_local_ip():
    s = None
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        return s.getsockname()[0]
    except Exception:
        return None
    finally:
        if s:
            s.close()

# ----------------------
# Wi-Fi helpers (Windows)
# ----------------------
def get_wifi_ssid():
    try:
        out = subprocess.check_output("netsh wlan show interfaces", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL, timeout=3)
        m = re.search(r"^\s*SSID\s*:\s(.+)$", out, re.I | re.M)
        if m:
            return m.group(1).strip()
    except Exception:
        pass
    return None

def list_access_points():
    aps = []
    try:
        out = subprocess.check_output("netsh wlan show networks mode=bssid", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL, timeout=5)
        ssid = None
        for line in out.splitlines():
            line = line.strip()
            if line.startswith("SSID"):
                p = line.split(":",1)
                if len(p) == 2:
                    ssid = p[1].strip()
            elif line.startswith("BSSID"):
                bssid = line.split(":",1)[1].strip()
            elif line.startswith("Signal"):
                signal = line.split(":",1)[1].strip()
                if ssid and bssid:
                    aps.append({"ssid": ssid, "bssid": bssid, "signal": signal})
    except Exception:
        pass
    return aps

def current_wifi_info():
    try:
        out = subprocess.check_output("netsh wlan show interfaces", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL, timeout=3)
        ssid_m = re.search(r"^\s*SSID\s*:\s(.+)$", out, re.I | re.M)
        bssid_m = re.search(r"^\s*BSSID\s*:\s(.+)$", out, re.I | re.M)
        rate_m = re.search(r"^\s*Receive rate \(Mbps\)\s*:\s(.+)$", out, re.I | re.M)
        sig_m = re.search(r"^\s*Signal\s*:\s(.+)$", out, re.I | re.M)
        return {
            "ssid": ssid_m.group(1).strip() if ssid_m else None,
            "bssid": bssid_m.group(1).strip() if bssid_m else None,
            "rate": rate_m.group(1).strip() if rate_m else None,
            "signal": sig_m.group(1).strip() if sig_m else None,
        }
    except Exception:
        return {}

# ----------------------
# Discovery: arp, nmap, both
# ----------------------
def arp_discover(network_cidr):
    console.print(f"[cyan]Running ARP discovery on {network_cidr}...[/cyan]")
    try:
        arp_request = scapy.ARP(pdst=network_cidr)
        broadcast = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
        packet = broadcast/arp_request
        answered = scapy.srp(packet, timeout=2, verbose=False)[0]
        devices = []
        for _, r in answered:
            devices.append({"ip": r.psrc, "mac": (r.hwsrc or "").upper(), "info": None})
        console.print(f"[green]ARP discovered {len(devices)} devices[/green]")
        return devices
    except Exception as e:
        console.print(f"[yellow]ARP discovery failed: {e}[/yellow]")
        return []

def nmap_discover(network_cidr):
    nm = nmap.PortScanner()
    devices = []
    if not shutil.which("nmap"):
        console.print("[yellow]nmap binary not found — falling back to ARP[/yellow]")
        return arp_discover(network_cidr)
    try:
        console.print(f"[cyan]Running nmap -sn {network_cidr}...[/cyan]")
        nm.scan(hosts=network_cidr, arguments="-sn")
        for host in nm.all_hosts():
            try:
                mac = nm[host]['addresses'].get('mac','').upper()
            except Exception:
                mac = ""
            devices.append({"ip": host, "mac": mac, "info": nm[host]})
        console.print(f"[green]Nmap discovered {len(devices)} hosts[/green]")
        return devices
    except Exception as e:
        console.print(f"[yellow]nmap discovery failed: {e} — falling back to ARP[/yellow]")
        return arp_discover(network_cidr)

def combined_discover(network_cidr):
    """Run both ARP and Nmap discovery and merge results (prefer ARP macs)."""
    arp_list = arp_discover(network_cidr)
    nmap_list = nmap_discover(network_cidr)
    merged = {}
    # take all from nmap_list first
    for d in nmap_list:
        ip = d.get("ip")
        if not ip:
            continue
        merged[ip] = {"ip": ip, "mac": d.get("mac","").upper(), "info": d.get("info")}
    # overlay arp mac addresses (prefer ARP mac if exists)
    for d in arp_list:
        ip = d.get("ip")
        if not ip:
            continue
        if ip in merged:
            # prefer ARP-provided MAC
            if d.get("mac"):
                merged[ip]["mac"] = d.get("mac").upper()
        else:
            merged[ip] = {"ip": ip, "mac": d.get("mac","").upper(), "info": None}
    devices = list(merged.values())
    console.print(f"[green]Combined discovery found {len(devices)} unique IPs[/green]")
    return devices

# ----------------------
# Nmap scan (per-host) - returns python-nmap host dict or None
# ----------------------
def nmap_scan_host(ip, mode="quick", timeout=15):
    try:
        nm = nmap.PortScanner()
    except Exception:
        return None
    # choose args
    args = "-sS -T4 --top-ports 20"
    if mode == "deep":
        args = "-sS -sV -O --top-ports 100 --osscan-guess --script vuln"
    try:
        nm.scan(hosts=ip, arguments=args, timeout=timeout)
        if ip in nm.all_hosts():
            return nm[ip]
    except Exception:
        return None
    return None

# ----------------------
# Ping helper
# ----------------------
def ping_device(ip, count=None):
    if count is None:
        count = CONFIG.get("ping_count", 4)
    system = platform.system().lower()
    if system == "windows":
        cmd = ["ping", "-n", str(count), ip]
    else:
        cmd = ["ping", "-c", str(count), ip]
    try:
        out = subprocess.check_output(cmd, universal_newlines=True, stderr=subprocess.DEVNULL, timeout=(count*3 + 5))
    except Exception:
        return None, None
    latency = None
    loss = None
    if system == "windows":
        m_avg = re.search(r"Average = (\d+)ms", out)
        m_loss = re.search(r"(\d+)%\s*loss", out, re.I) or re.search(r"Lost = \d+,.*Lost = \d+", out)
        if m_avg:
            latency = float(m_avg.group(1))
        if m_loss:
            try:
                loss = float(m_loss.group(1))
            except Exception:
                loss = None
    else:
        m_avg = re.search(r"rtt [\w/]+ = [\d\.]+/([\d\.]+)/", out)
        m_loss = re.search(r"(\d+)% packet loss", out)
        if m_avg:
            latency = float(m_avg.group(1))
        if m_loss:
            loss = float(m_loss.group(1))
    return latency, loss

# ----------------------
# Device role inference
# ----------------------
def detect_device_role(device: dict) -> str:
    """
    Return a human‑readable role for *device* based on:
        • vendor string (contains "raspberry", "amazon", …)
        • OS name (contains "linux", "windows", "macos", “ios”, etc.)
        • open port list (22, 80, 443, 9100, 3389, …)

    The function is deliberately tolerant – it never raises an exception,
    so enrichment can continue even if some fields are missing.
    """
    vendor = (device.get("vendor") or "").lower()
    os_name = (device.get("os") or "").lower()
    hostname = (device.get("hostname") or "").lower()

    # ---------- 1. Port‑based heuristics (your original logic) ----------
    open_ports_str = device.get("open_ports", "")
    try:
        open_ports = {int(p) for p in re.findall(r"\d+", str(open_ports_str))}
    except Exception:
        open_ports = set()

    # Cameras / surveillance
    if 554 in open_ports or 8554 in open_ports \
       or "camera" in vendor or "hikvision" in vendor or "dahua" in vendor:
        return "IP Camera / Surveillance"

    # Printers
    if 9100 in open_ports:
        return "Printer"

    # Remote Desktop
    if 3389 in open_ports:
        return "Windows Remote Desktop"

    # SSH hosts (Linux/Embedded)
    if 22 in open_ports and not {80, 443}.intersection(open_ports):
        if any(x in vendor for x in ("raspberry", "pi")) or "linux" in os_name:
            return "Raspberry Pi / Embedded"
        return "SSH Host (Linux/Embedded)"

    # Web interfaces
    if 80 in open_ports or 443 in open_ports:
        # Routers/gateways
        if "router" in os_name or hostname.endswith(".1"):
            return "Router / Gateway"
        # NAS/File servers
        if any(x in vendor for x in ("synology", "qnap")) \
           or "nas" in os_name:
            return "NAS / File Server"
        return "Web Interface Device"

    # ---------- 2. OS‑based heuristics (new) ----------
    # If the OS string contains a keyword, use it
    if any(x in os_name for x in ("windows", "microsoft")):
        return "Windows Desktop/Laptop"
    if any(x in os_name for x in ("macos", "darwin")):
        return "Apple Mac (Desktop/Server)"
    if any(x in os_name for x in ("ios", "iphone", "ipad")):
        return "Apple Mobile (iPhone/iPad)"
    if any(x in os_name for x in ("android", "samsung")):
        return "Android Mobile"
    if any(x in os_name for x in ("linux", "unix", "freebsd")):
        # Avoid clashing with SSH logic above
        return "Linux/Unix Host"

    # ---------- 3. Vendor‑based heuristics (fallback) ----------
    # Some vendors are strongly associated with a role
    if any(x in vendor for x in ("amazon", "aws")):
        return "Amazon EC2 / Cloud Instance"
    if any(x in vendor for x in ("google", "nest", "chromecast")):
        return "Google IoT Device"
    if any(x in vendor for x in ("philips", "hue")):
        return "Philips Hue Light"

    # ---------- 4. Default ----------
    return "Generic Device"


# ----------------------
# Enrichment
# ----------------------
def enrich_device(device, mode="quick"):
    ip = device.get("ip")
    if not ip:
        return device
    mac = (device.get("mac") or "").upper()
    # vendor
    device["vendor"] = mac_vendor_lookup(mac)
    # nmap per-host
    ndata = None
    if shutil.which("nmap"):
        ndata = nmap_scan_host(ip, mode=mode, timeout=CONFIG["device_processing_timeout"])
    # parse nmap results
    if ndata:
        # OS guess
        os_guess = "Unknown"
        try:
            if "osmatch" in ndata and ndata["osmatch"]:
                os_guess = ndata["osmatch"][0].get("name","Unknown")
            elif "osclass" in ndata and ndata["osclass"]:
                os_guess = ndata["osclass"][0].get("osfamily","Unknown")
        except Exception:
            os_guess = "Unknown"
        device["os"] = os_guess
        # open ports
        try:
            tcp = ndata.get("tcp", {}) or {}
            open_ports = [int(p) for p,info in tcp.items() if (info.get("state","") if isinstance(info, dict) else getattr(info,"state","")).lower() == "open"]
            device["open_ports"] = ", ".join(str(p) for p in sorted(open_ports)) if open_ports else "None"
        except Exception:
            device["open_ports"] = "Unknown"
        # vulnerabilities: hostscript or scripts
        vulns = []
        try:
            hostscript = ndata.get("hostscript", []) or []
            for s in hostscript:
                out = s.get("output") if isinstance(s, dict) else None
                if out:
                    vulns.append(out.strip())
            tcp = ndata.get("tcp", {}) or {}
            for p,info in tcp.items():
                scripts = info.get("script", {}) if isinstance(info, dict) else {}
                if isinstance(scripts, dict):
                    for sid, st in scripts.items():
                        vulns.append(f"Port {p}: {sid} - {st}")
        except Exception:
            pass
        device["vulnerabilities"] = "; ".join(vulns) if vulns else "None found"
    else:
        device.setdefault("os", "Unknown")
        device.setdefault("open_ports", "Unknown")
        device.setdefault("vulnerabilities", "Unknown or not scanned")
    # ping
    lat, loss = ping_device(ip, count=CONFIG.get("ping_count",4))
    device["latency_ms"] = f"{lat:.1f}" if lat is not None else "N/A"
    device["packet_loss_pct"] = f"{loss:.0f}%" if loss is not None else "N/A"
    # hostname
    try:
        device["hostname"] = socket.getfqdn(ip) or ip
    except Exception:
        device["hostname"] = ip
    # role
    device["role"] = detect_device_role(device)
    now = datetime.utcnow().isoformat() + "Z"
    device.setdefault("discovered_at", now)
    device["last_seen_at"] = now
    return device

def enrich_devices(devices, mode="quick"):
    total = len(devices)
    if total == 0:
        return []
    console.print(f"[cyan]Enriching {total} devices (workers={CONFIG['device_thread_workers']})[/cyan]")
    enriched = []
    with Progress(SpinnerColumn(), "[progress.description]{task.description}", BarColumn(), "{task.completed}/{task.total}", TimeRemainingColumn(), console=console) as progress:
        task = progress.add_task("Enriching...", total=total)
        with ThreadPoolExecutor(max_workers=CONFIG["device_thread_workers"]) as exe:
            futures = {exe.submit(enrich_device, d, mode): d for d in devices}
            for fut in as_completed(futures):
                try:
                    dev = fut.result(timeout=CONFIG["device_processing_timeout"])
                except TimeoutError:
                    d = futures[fut]
                    console.print(f"[red]Timeout enriching {d.get('ip')}[/red]")
                    d.setdefault("os", "Timeout")
                    d.setdefault("open_ports", "Timeout")
                    d.setdefault("vulnerabilities", "Timeout")
                    d.setdefault("latency_ms", "N/A")
                    d.setdefault("packet_loss_pct", "N/A")
                    d.setdefault("role", "Unknown")
                    dev = d
                except Exception as e:
                    d = futures[fut]
                    console.print(f"[red]Error enriching {d.get('ip')}: {e}[/red]")
                    dev = d
                enriched.append(dev)
                progress.update(task, advance=1)
    return enriched

# ----------------------
# Capture traffic
# ----------------------
def capture_traffic(duration=20):
    console.print(f"[cyan]Sniffing traffic for {duration}s to detect communications (optional)...[/cyan]")
    try:
        pkts = scapy.sniff(timeout=duration)
    except Exception as e:
        console.print(f"[yellow]Sniffer failed: {e}[/yellow]")
        return {}
    comms = defaultdict(set)
    for pkt in pkts:
        if pkt.haslayer(scapy.IP):
            try:
                s = pkt[scapy.IP].src
                d = pkt[scapy.IP].dst
                comms[s].add(d)
                comms[d].add(s)
            except Exception:
                pass
    return comms

# ----------------------------------------------------------------------
# Report
# ----------------------------------------------------------------------
def generate_report(devices, communications, excel_path):
    # 1️⃣  Add OS to the column list (Vendor and Role are already there)
    headers = [
        "IP",          # 0
        "MAC",         # 1
        "Vendor",      # 2
        "Hostname",    # 3
        "OS",          # 4   ← NEW
        "Role",        # 5
        "Open Ports",  # 6
        "Vulnerabilities",  # 7
        "Latency (ms)",     # 8
        "Packet Loss",      # 9
        "Discovered At",    #10
        "Last Seen",        #11
        "External Comms"    #12
    ]

    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Scan Report"
    ws.append(headers)

    tbl = Table(title="ZeroTrace Scan Report", show_lines=False)
    for h in headers:
        tbl.add_column(h)

    # 2️⃣ Pull the OS value explicitly (default to “Unknown” if missing)
    for d in devices:
        ip       = d.get("ip","")
        mac      = d.get("mac","")
        vendor   = d.get("vendor","")
        hostname = d.get("hostname", ip)
        os_name  = d.get("os","Unknown")          # ← NEW
        role     = d.get("role","Generic Device")
        openp    = d.get("open_ports","")
        vulns    = d.get("vulnerabilities","")
        lat      = d.get("latency_ms","")
        loss     = d.get("packet_loss_pct","")
        disc     = d.get("discovered_at","")
        last     = d.get("last_seen_at","")
        ext      = ", ".join(sorted(communications.get(ip, []))) if communications and ip in communications else "None observed"

        ws.append([ip, mac, vendor, hostname, os_name, role,
                   openp, vulns, lat, loss, disc, last, ext])

        tbl.add_row(str(ip), str(mac), str(vendor), str(hostname),
                    str(os_name), str(role), str(openp), str(vulns),
                    str(lat), str(loss), str(disc), str(last), str(ext))

    # ------------------------------------------------------------------
    # The rest of the function (network context, AP sheet, etc.) stays
    # exactly as it was in your original code.
    # ------------------------------------------------------------------

    ws.append([])  # blank line before context section
    try:
        out = subprocess.check_output("netsh interface ip show addresses", shell=True,
                                      universal_newlines=True, stderr=subprocess.DEVNULL)
        m = re.search(r"Default Gateway:\s*([0-9.]+)", out)
        if m:
            ws.append(["Default Gateway", m.group(1)])
    except Exception:
        pass

    # Access‑Point sheet (unchanged)
    aps = list_access_points()
    curr = current_wifi_info()
    ws_ap = wb.create_sheet("Access Points")
    ws_ap.append(["SSID","BSSID","Signal","Type","Current"])
    ssid_counts = Counter([a.get("ssid") for a in aps if a.get("ssid")])
    for a in aps:
        typ = "Mesh/Extender" if ssid_counts[a.get("ssid")] > 1 else "Primary"
        is_cur = ""
        if curr and curr.get("bssid") and a.get("bssid") and a.get("bssid").lower() == curr.get("bssid","").lower():
            is_cur = "Yes"
        ws_ap.append([a.get("ssid"), a.get("bssid"), a.get("signal"),
                      typ, is_cur])

    ws_ap.append([])
    ws_ap.append(["Current Connection","SSID","BSSID","Rate (Mbps)","Signal"])
    ws_ap.append(["", curr.get("ssid",""), curr.get("bssid",""),
                   curr.get("rate",""), curr.get("signal","")])

    console.print(tbl)

    try:
        wb.save(excel_path)
        console.print(f"[green]✔ Report saved to {os.path.abspath(excel_path)}[/green]")
    except Exception as e:
        console.print(f"[red]Failed to save Excel: {e}[/red]")


# ----------------------
# Orchestration
# ----------------------
def scan_network(mode="quick", discovery_method="nmap"):
    local_ip = get_local_ip()
    if not local_ip:
        console.print("[red]Couldn't determine local IP - aborting[/red]")
        return []
    network_cidr = str(ipaddress.ip_network(f"{local_ip}/24", strict=False))
    console.print(f"[blue]Discovery range: {network_cidr}[/blue]")
    if discovery_method == "arp":
        discovered = arp_discover(network_cidr)
    elif discovery_method == "nmap":
        discovered = nmap_discover(network_cidr)
    else:
        discovered = combined_discover(network_cidr)
    # vendor quick summary
    vendors = [mac_vendor_lookup(d.get("mac")) for d in discovered]
    counts = Counter(vendors)
    sample = ", ".join(list(counts.keys())[:8])
    console.print(f"[green]Vendors detected ({len(counts)}): {sample}[/green]")
    console.print(f"[cyan]Devices discovered: {len(discovered)}[/cyan]")
    return discovered

def main():
    console.print("[bold cyan]ZeroTrace — ARP + Nmap Combined Scanner[/bold cyan]")
    if is_admin():
        console.print("[green]✔ Running as Administrator[/green]")
    else:
        console.print("[yellow]⚠ Not running as Administrator — deep OS/vuln detection may be limited[/yellow]")
    conn_type = "Wi-Fi" if get_wifi_ssid() else "Ethernet"
    ssid = get_wifi_ssid() if conn_type == "Wi-Fi" else None
    console.print(f"[blue]Connection type:[/] {conn_type}")
    if ssid:
        console.print(f"[blue]Connected SSID:[/] {ssid}")
    # discovery mode: arp, nmap, both
    disc = console.input("[cyan]Discovery method ([b]nmap[/b]/[b]arp[/b]/[b]both[/b]) [both]: ").strip().lower() or "both"
    if disc not in ("nmap","arp","both"):
        disc = "both"
    # quick or deep
    mode = console.input("[cyan]Scan mode ([b]quick[/b]/[b]deep[/b]) [quick]: ").strip().lower() or "quick"
    if mode not in ("quick","deep"):
        mode = "quick"
    discovered = scan_network(mode=mode, discovery_method=disc)
    if not discovered:
        console.print("[red]No devices discovered — exiting[/red]")
        return
    # optional short sniff for comms
    communications = {}
    try:
        communications = capture_traffic(CONFIG.get("sniff_seconds", 20))
    except Exception:
        communications = {}
    enriched = enrich_devices(discovered, mode=mode)
    generate_report(enriched, communications, CONFIG.get("excel_output"))
    console.print("[green]Done.[/green]")

if __name__ == "__main__":
    main()
'''






'''                                                                             #------------------------------Vendor & OS(eh) WORK--------------------------------------------------
import os
import re
import ipaddress
import platform
import socket
import subprocess
import ctypes
import shutil
from concurrent.futures import ThreadPoolExecutor, as_completed
from collections import Counter
from datetime import datetime

import scapy.all as scapy
import nmap
import openpyxl
import requests
from rich.console import Console
from rich.table import Table
from rich.progress import Progress, BarColumn, SpinnerColumn, TimeRemainingColumn

console = Console()

CONFIG = {
    "excel_output": "zerotrace_report.xlsx",
    "device_thread_workers": 20,
    "scan_thread_workers": 30,
}

# ------------------------------------------------------------------------------------
#  LOAD LOCAL OUI FILE
# ------------------------------------------------------------------------------------
OUI_VENDOR_MAP = {}
OUI_FILE_PATH = os.path.join(os.path.dirname(__file__), "oui.txt")

def load_oui_file():
    global OUI_VENDOR_MAP
    if not os.path.exists(OUI_FILE_PATH):
        console.print("[yellow]OUI file not found; vendor lookups may be limited.[/yellow]")
        return
    try:
        with open(OUI_FILE_PATH, "r", encoding="utf-8", errors="ignore") as f:
            for line in f:
                if "(hex)" in line:
                    parts = line.strip().split("(hex)")
                    if len(parts) == 2:
                        prefix = parts[0].strip().replace("-", "").replace(":", "").upper()[:6]
                        vendor = parts[1].strip()
                        if prefix:
                            OUI_VENDOR_MAP[prefix] = vendor
        console.print(f"[green]✔ Loaded {len(OUI_VENDOR_MAP):,} OUIs from oui.txt[/green]")
    except Exception as e:
        console.print(f"[red]Failed to load OUI file: {e}[/red]")

def mac_vendor_lookup(mac):
    if not mac:
        return "Unknown Vendor"
    mac_norm = mac.upper().replace("-", "").replace(":", "")
    prefix = mac_norm[:6]
    if prefix in OUI_VENDOR_MAP:
        return OUI_VENDOR_MAP[prefix]
    try:
        r = requests.get(f"https://api.macvendors.com/{mac}", timeout=3)
        if r.status_code == 200 and r.text.strip():
            return r.text.strip()
    except Exception:
        pass
    return "Unknown Vendor"

# ------------------------------------------------------------------------------------
#  SYSTEM HELPERS
# ------------------------------------------------------------------------------------
def is_admin():
    try:
        return os.getuid() == 0
    except AttributeError:
        return ctypes.windll.shell32.IsUserAnAdmin() != 0

def get_local_ip():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(("8.8.8.8", 80))
        return s.getsockname()[0]
    except Exception:
        return None
    finally:
        s.close()

# ------------------------------------------------------------------------------------
#  DISCOVERY METHODS
# ------------------------------------------------------------------------------------
def arp_discover(network_cidr):
    console.print(f"[cyan]Running ARP discovery on {network_cidr}...[/cyan]")
    arp = scapy.ARP(pdst=network_cidr)
    broadcast = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
    packet = broadcast / arp
    answered = scapy.srp(packet, timeout=3, verbose=False)[0]
    devices = []
    for _, r in answered:
        devices.append({"ip": r.psrc, "mac": (r.hwsrc or "").upper()})
    console.print(f"[green]ARP discovered {len(devices)} devices[/green]")
    return devices

def nmap_discover(network_cidr):
    nm = nmap.PortScanner()
    if not shutil.which("nmap"):
        console.print("[yellow]nmap not found; using ARP instead.[/yellow]")
        return arp_discover(network_cidr)
    console.print(f"[cyan]Running Nmap discovery on {network_cidr}...[/cyan]")
    nm.scan(hosts=network_cidr, arguments="-sn")
    devices = []
    for host in nm.all_hosts():
        mac = nm[host]["addresses"].get("mac", "").upper() if "addresses" in nm[host] else ""
        devices.append({"ip": host, "mac": mac})
    console.print(f"[green]Nmap discovered {len(devices)} hosts[/green]")
    return devices

# ------------------------------------------------------------------------------------
#  SCAN & CLASSIFICATION
# ------------------------------------------------------------------------------------
def ping_device(ip):
    try:
        out = subprocess.check_output(["ping", "-n", "3", ip], universal_newlines=True, stderr=subprocess.DEVNULL)
        m_avg = re.search(r"Average = (\d+)ms", out)
        m_loss = re.search(r"Lost = \d+, *\( *(\d+)% loss", out)
        latency = float(m_avg.group(1)) if m_avg else None
        loss = float(m_loss.group(1)) if m_loss else None
        return latency, loss
    except Exception:
        return None, None

def nmap_scan_host(ip, mode="quick"):
    nm = nmap.PortScanner()
    try:
        args = "-sS -T4 --top-ports 25" if mode == "quick" else "-sS -sV -O --osscan-guess --top-ports 200 --script vuln"
        nm.scan(ip, arguments=args, timeout=60)
        return nm[ip] if ip in nm.all_hosts() else None
    except Exception:
        return None

def infer_role(vendor, osname, open_ports):
    v = vendor.lower()
    o = osname.lower()
    ports = set(open_ports)
    if any(p in ports for p in (554, 8554, 8081)) or "camera" in o or "hikvision" in v:
        return "IP Camera"
    if "iphone" in o or "ios" in o or "ipad" in o or "apple" in v:
        return "iPhone/iPad"
    if "android" in o or "samsung" in v or "xiaomi" in v:
        return "Android Phone"
    if any(k in v for k in ("hp", "dell", "lenovo", "microsoft")) or "windows" in o:
        return "Laptop/Desktop"
    if any(p in ports for p in (22, 80, 443)) and "linux" in o:
        return "Server/Linux Host"
    if "roku" in v or "amazon" in v or "chromecast" in v:
        return "Streaming Device"
    if "printer" in v or 9100 in ports:
        return "Printer"
    if any(k in v for k in ("tp-link", "cisco", "netgear", "arris", "eero")):
        return "Router/Switch"
    if any(k in v for k in ("nest", "philips hue", "wyze", "tado", "google nest")):
        return "Smart Home Device"
    return "Generic Device"

# ------------------------------------------------------------------------------------
#  ENRICH DEVICE INFO
# ------------------------------------------------------------------------------------
def enrich_device(d, mode="quick"):
    ip = d.get("ip")
    mac = d.get("mac", "")
    vendor = mac_vendor_lookup(mac)

    nmdata = nmap_scan_host(ip, mode)
    osname = "Unknown"
    open_ports = []
    vulns = []

    if nmdata:
        if nmdata.get("osmatch"):
            osname = nmdata["osmatch"][0].get("name", "Unknown")
        elif nmdata.get("osclass"):
            osname = nmdata["osclass"][0].get("osfamily", "Unknown")
        tcp = nmdata.get("tcp", {})
        for p, info in tcp.items():
            if info.get("state") == "open":
                open_ports.append(int(p))
        if nmdata.get("hostscript"):
            for s in nmdata["hostscript"]:
                vulns.append(f"{s.get('id')}: {s.get('output')}")

    latency, loss = ping_device(ip)
    role = infer_role(vendor, osname, open_ports)
    return {
        "ip": ip,
        "mac": mac,
        "vendor": vendor,
        "os": osname,
        "latency": f"{latency:.1f} ms" if latency else "N/A",
        "packet_loss": f"{loss:.0f}%" if loss else "N/A",
        "open_ports": ", ".join(map(str, open_ports)) if open_ports else "None",
        "role": role,
        "vulnerabilities": "; ".join(vulns) if vulns else "None",
    }

# ------------------------------------------------------------------------------------
#  REPORT
# ------------------------------------------------------------------------------------
def generate_report(devices):
    headers = ["IP", "MAC", "Vendor", "OS", "Role", "Latency", "Packet Loss", "Open Ports", "Vulnerabilities"]
    table = Table(title="ZeroTrace Network Summary", show_lines=False)
    for h in headers:
        table.add_column(h, overflow="fold")

    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Scan Report"
    ws.append(headers)

    for dev in devices:
        row = [dev.get(k.lower().replace(" ", "_"), "") for k in headers]
        ws.append(row)
        table.add_row(*map(str, row))

    wb.save(CONFIG["excel_output"])
    console.print(table)
    console.print(f"[green]✔ Report saved to {os.path.abspath(CONFIG['excel_output'])}[/green]")

# ------------------------------------------------------------------------------------
#  MAIN
# ------------------------------------------------------------------------------------
def main():
    console.print("[bold cyan]ZeroTrace Enterprise Network Scanner[/bold cyan]")
    load_oui_file()

    mode = console.input("[cyan]Scan mode ([b]quick[/b]/[b]deep[/b]/[b]both[/b]): ").strip().lower() or "quick"
    disc = console.input("[cyan]Discovery method ([b]nmap[/b]/[b]arp[/b]/[b]both[/b]) [nmap]: ").strip().lower() or "nmap"

    local_ip = get_local_ip()
    if not local_ip:
        console.print("[red]Could not determine local IP address.[/red]")
        return
    network_cidr = str(ipaddress.ip_network(f"{local_ip}/24", strict=False))
    console.print(f"[blue]Scanning subnet: {network_cidr}[/blue]")

    if disc == "arp":
        devices = arp_discover(network_cidr)
    elif disc == "nmap":
        devices = nmap_discover(network_cidr)
    else:
        arp_list = arp_discover(network_cidr)
        nmap_list = nmap_discover(network_cidr)
        ipmap = {d["ip"]: d for d in arp_list}
        for n in nmap_list:
            if n["ip"] not in ipmap:
                ipmap[n["ip"]] = n
            elif not ipmap[n["ip"]].get("mac"):
                ipmap[n["ip"]]["mac"] = n.get("mac", "")
        devices = list(ipmap.values())

    if not devices:
        console.print("[red]No devices discovered.[/red]")
        return

    console.print(f"[cyan]Discovered {len(devices)} devices — scanning in {mode} mode...[/cyan]")
    enriched = []
    with Progress(SpinnerColumn(), "[progress.description]{task.description}", BarColumn(), "{task.completed}/{task.total}", TimeRemainingColumn()) as progress:
        task = progress.add_task("Scanning devices", total=len(devices))
        with ThreadPoolExecutor(max_workers=CONFIG["device_thread_workers"]) as ex:
            futures = {ex.submit(enrich_device, d, "deep" if mode in ("deep", "both") else "quick"): d for d in devices}
            for f in as_completed(futures):
                try:
                    enriched.append(f.result())
                except Exception:
                    enriched.append(futures[f])
                progress.update(task, advance=1)

    generate_report(enriched)

if __name__ == "__main__":
    main()
'''





'''
# ZeroTrace — Combined Network & Access Point Scanner
import scapy.all as scapy
import socket
import ipaddress
import nmap
import os
import ctypes
import platform
import subprocess
import time
from rich.console import Console
from rich.table import Table
from rich.progress import Progress
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor, as_completed, TimeoutError
import requests
import openpyxl
import re
import shutil

console = Console()

# ----------------------
# Config
# ----------------------
CONFIG = {
    "sniff_seconds": 60, # Adjust duration of packet capture here
    "excel_output": "zerotrace_report.xlsx", # Can change output filename here
    "device_processing_timeout": 10,   # seconds allowed per device when generating report
    "device_thread_workers": 20,       # parallelism for report generation
    "scan_thread_workers": 30,         # parallelism for scanning
}

# ----------------------
# Quick OUI Vendor Map (local fallback)
# ----------------------
OUI_VENDOR_MAP = {
    "B8:27:EB": "Raspberry Pi Foundation",
    "DC:A6:32": "Amazon Technologies",
    "AC:63:BE": "Amazon Echo",
    "3C:5A:B4": "Wyze Labs",
    "F4:F5:D8": "Google Nest",
    "D0:73:D5": "Google Smart Hub",
    "00:1A:11": "Philips Hue",
    "F0:27:2D": "TP-Link Technologies",
    "60:01:94": "Xiaomi Communications",
    "28:6D:97": "Samsung Electronics",
    "00:16:6C": "Sony Corporation",
    "F0:18:98": "Apple, Inc."
}

# ----------------------
# Utility: Check admin privileges
# ----------------------
def is_admin():
    try:
        return os.getuid() == 0  # Linux / macOS
    except AttributeError:
        try:
            return ctypes.windll.shell32.IsUserAnAdmin() != 0  # Windows
        except Exception:
            return False

# ----------------------
# Improved MAC Vendor Lookup
# ----------------------
def mac_vendor_lookup(mac):
    if not mac:
        return "Unknown Vendor"
    mac_norm = mac.upper().replace(":", "").replace("-", "")
    oui = mac_norm[:6]
    prefix = ":".join([oui[i:i+2] for i in range(0, 6, 2)])
    vendor = OUI_VENDOR_MAP.get(prefix) or OUI_VENDOR_MAP.get(oui)
    if vendor:
        return vendor
    try:
        url = f"https://api.macvendors.com/{mac}"
        r = requests.get(url, timeout=4)
        if r.status_code == 200 and r.text:
            return r.text.strip()
    except Exception:
        pass
    return "Unknown Vendor"

# ----------------------
# Hostname / Custom Name detection
# ----------------------
def get_reverse_dns(ip):
    try:
        name = socket.gethostbyaddr(ip)[0]
        return name
    except Exception:
        return None

def get_nmap_hostnames(info):
    try:
        if info and isinstance(info, dict) and "hostnames" in info and info["hostnames"]:
            for h in info["hostnames"]:
                name = h.get("name")
                if name:
                    return name
    except Exception:
        pass
    return None

def get_netbios_name(ip):
    if platform.system().lower() != "windows":
        return None
    try:
        out = subprocess.check_output(["nbtstat", "-A", ip], universal_newlines=True, stderr=subprocess.DEVNULL, timeout=5)
        m = re.search(r"^\s*([^\s<]+)\s+<00>\s+UNIQUE", out, re.I | re.M)
        if m:
            return m.group(1)
    except Exception:
        pass
    return None

def get_custom_name(ip, info):
    rdns = get_reverse_dns(ip)
    if rdns and rdns != ip:
        return rdns
    nmname = get_nmap_hostnames(info)
    if nmname:
        return nmname
    nb = get_netbios_name(ip)
    if nb:
        return nb
    return "Unknown"

# ----------------------
# Ping Latency
# ----------------------
def ping_latency_ms(ip, attempts=2, timeout_ms=800):
    try:
        system = platform.system().lower()
        if system == "windows":
            cmd = ["ping", "-n", str(attempts), "-w", str(timeout_ms), ip]
        else:
            t = max(1, int(timeout_ms / 1000))
            cmd = ["ping", "-c", str(attempts), "-W", str(t), ip]
        proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True,
                              timeout=(attempts * (timeout_ms / 1000) + 3))
        out = proc.stdout
        if not out:
            return None
        if system == "windows":
            m = re.search(r"Average = (\d+)ms", out)
            if m:
                return float(m.group(1))
        else:
            m = re.search(r"rtt [\w/]+ = [\d\.]+/([\d\.]+)/", out)
            if m:
                return float(m.group(1))
    except Exception:
        return None
    return None

# ----------------------
# Wi-Fi SSID (local host)
# ----------------------
def get_wifi_ssid():
    try:
        system = platform.system().lower()
        if system == "windows":
            out = subprocess.check_output("netsh wlan show interfaces", shell=True, stderr=subprocess.DEVNULL,
                                          universal_newlines=True, timeout=3)
            m = re.search(r"SSID\s*:\s(.+)", out)
            if m:
                return m.group(1).strip()
        else:
            out = subprocess.check_output("iwgetid -r", shell=True, stderr=subprocess.DEVNULL,
                                          universal_newlines=True, timeout=3).strip()
            return out if out else "Unknown"
    except Exception:
        return "Unknown"

# ----------------------
# Access Point Detection
# ----------------------
def list_access_points():
    system = platform.system().lower()
    aps = []

    if system == "windows":
        try:
            out = subprocess.check_output(
                "netsh wlan show networks mode=bssid",
                shell=True, universal_newlines=True, stderr=subprocess.DEVNULL
            )
            ssid, bssid, signal = None, None, None
            for line in out.splitlines():
                if "SSID" in line and "BSSID" not in line:
                    ssid = line.split(":", 1)[1].strip()
                elif "BSSID" in line:
                    bssid = line.split(":", 1)[1].strip()
                elif "Signal" in line:
                    signal = line.split(":", 1)[1].strip()
                    if ssid and bssid:
                        aps.append({"ssid": ssid, "bssid": bssid, "signal": signal})
        except Exception as e:
            aps.append({"error": f"AP scan failed: {e}"})

    elif system == "linux":
        try:
            out = subprocess.check_output(
                "nmcli -t -f SSID,BSSID,SIGNAL dev wifi",
                shell=True, universal_newlines=True, stderr=subprocess.DEVNULL
            )
            for line in out.strip().split("\n"):
                parts = line.split(":")
                if len(parts) >= 3:
                    aps.append({"ssid": parts[0], "bssid": parts[1], "signal": parts[2]})
        except Exception as e:
            aps.append({"error": f"AP scan failed: {e}"})

    return aps

def current_connection():
    system = platform.system().lower()
    if system == "windows":
        try:
            out = subprocess.check_output(
                "netsh wlan show interfaces",
                shell=True, universal_newlines=True, stderr=subprocess.DEVNULL
            )
            ssid = re.search(r"SSID\s*:\s(.+)", out)
            bssid = re.search(r"BSSID\s*:\s(.+)", out)
            rate = re.search(r"Receive rate \(Mbps\)\s*:\s(.+)", out)
            signal = re.search(r"Signal\s*:\s(.+)", out)
            return {
                "ssid": ssid.group(1).strip() if ssid else None,
                "bssid": bssid.group(1).strip() if bssid else None,
                "rate": rate.group(1).strip() if rate else None,
                "signal": signal.group(1).strip() if signal else None
            }
        except Exception:
            return {}
    elif system == "linux":
        try:
            out = subprocess.check_output("iw dev wlan0 link", shell=True, universal_newlines=True,
                                          stderr=subprocess.DEVNULL)
            ssid = re.search(r"SSID: (.+)", out)
            bssid = re.search(r"Connected to (.+)", out)
            rate = re.search(r"tx bitrate: (.+)", out)
            return {
                "ssid": ssid.group(1).strip() if ssid else None,
                "bssid": bssid.group(1).strip() if bssid else None,
                "rate": rate.group(1).strip() if rate else None
            }
        except Exception:
            return {}
    return {}

# ----------------------
# Discovery helpers
# ----------------------
def arp_discover(network_cidr):
    console.print(f"[cyan]Running ARP discovery on {network_cidr}...[/cyan]")
    arp_request = scapy.ARP(pdst=network_cidr)
    broadcast = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
    arp_request_broadcast = broadcast/arp_request
    answered = scapy.srp(arp_request_broadcast, timeout=2, verbose=False)[0]
    devices = []
    for _, received in answered:
        devices.append({"ip": received.psrc, "mac": (received.hwsrc or "").upper(), "info": None})
    console.print(f"[green]ARP discovered {len(devices)} devices[/green]")
    return devices

def nmap_discover(network_cidr):
    nm = nmap.PortScanner()
    devices = []
    if not shutil.which("nmap"):
        console.print("[yellow]nmap binary not found in PATH — falling back to ARP discovery[/yellow]")
        return arp_discover(network_cidr)
    try:
        console.print(f"[cyan]Trying python-nmap discovery on {network_cidr}...[/cyan]")
        nm.scan(hosts=network_cidr, arguments="-sn")
        for host in nm.all_hosts():
            try:
                mac = nm[host]['addresses'].get('mac', '').upper()
            except Exception:
                mac = ""
            devices.append({"ip": host, "mac": mac, "info": nm[host] if host in nm.all_hosts() else None})
        console.print(f"[green]python-nmap discovered {len(devices)} hosts[/green]")
        return devices
    except Exception as e:
        console.print(f"[yellow]python-nmap discovery failed: {e} — falling back to ARP[/yellow]")
        return arp_discover(network_cidr)

def get_discovered_devices(network_cidr, method="nmap"):
    if method == "nmap":
        return nmap_discover(network_cidr)
    else:
        return arp_discover(network_cidr)

# ----------------------
# Device scan (per-host Nmap)
# ----------------------
def scan_device(ip, mode="quick"):
    nm = nmap.PortScanner()
    try:
        if mode == "quick":
            args = "-sS -T4 --top-ports 20"
        else:
            args = "-sS -sV -O --top-ports 100 --osscan-guess --script vuln --max-retries 2"
        nm.scan(ip, arguments=args, timeout=45)
        return nm[ip] if ip in nm.all_hosts() else {}
    except Exception as e:
        console.print(f"[yellow][!] Scan error for {ip}: {e}[/yellow]")
        return {}

# ----------------------
# Scan network (discovery + per-host scanning)
# ----------------------
def get_local_ip():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
    except Exception:
        ip = None
    finally:
        s.close()
    return ip

def scan_network(mode="quick", discovery_method="nmap"):
    local_ip = get_local_ip()
    if not local_ip:
        console.print("[red]Could not detect local IP. Exiting.[/red]")
        return []
    network_cidr = str(ipaddress.ip_network(f"{local_ip}/24", strict=False))
    console.print(f"[blue]Using discovery range: {network_cidr}[/blue]")
    discovered = get_discovered_devices(network_cidr, method=discovery_method)
    console.print(f"[cyan]Beginning detailed scans for {len(discovered)} discovered devices...[/cyan]")
    results = []
    with Progress() as progress:
        task = progress.add_task("[green]Scanning devices...", total=len(discovered))
        with ThreadPoolExecutor(max_workers=CONFIG["scan_thread_workers"]) as executor:
            future_to_dev = {executor.submit(scan_device, d["ip"], mode): d for d in discovered}
            for future in as_completed(future_to_dev):
                dev = future_to_dev[future]
                try:
                    info = future.result(timeout=60)
                except Exception as e:
                    console.print(f"[red][!] Error scanning {dev['ip']}: {e}[/red]")
                    info = {}
                results.append({"ip": dev["ip"], "mac": dev.get("mac", ""), "info": info})
                progress.update(task, advance=1)
    return results

# ----------------------
# Phase 2: Traffic Capture
# ----------------------
def capture_traffic(duration=60):
    console.print(f"[cyan]Sniffing network traffic for {duration} seconds...[/cyan]")
    try:
        packets = scapy.sniff(timeout=duration)
    except Exception as e:
        console.print(f"[yellow]Sniff failed ({e}); continuing without traffic capture[/yellow]")
        packets = []
    communications = defaultdict(set)
    for pkt in packets:
        if pkt.haslayer(scapy.IP):
            try:
                src = pkt[scapy.IP].src
                dst = pkt[scapy.IP].dst
                communications[src].add(dst)
                communications[dst].add(src)
            except Exception:
                continue
    return communications

# ----------------------
# Risk Analysis
# ----------------------
def analyze_risks(info):
    if not info:
        return ["Unreachable"]
    risks = []
    risky_ports = {
        21: "FTP (insecure)",
        23: "Telnet (plaintext)",
        25: "SMTP exposed",
        53: "DNS tunneling risk",
        111: "RPC exploit",
        135: "MS RPC risk",
        139: "NetBIOS exploit",
        445: "SMB vulnerability",
        3389: "RDP exposed",
        5900: "VNC exposed"
    }
    try:
        protocols = info.all_protocols() if info else []
    except Exception:
        protocols = []
    for proto in protocols:
        ports = info.get(proto, {}) if isinstance(info, dict) else info.get(proto, {})
        for port, svc in ports.items():
            try:
                state = svc.get("state", "") if isinstance(svc, dict) else ""
            except Exception:
                state = ""
            if state == "open":
                if port in risky_ports:
                    risks.append(f"Critical: {risky_ports[port]}")
                elif port in (80, 8080, 8443):
                    risks.append("Medium: Web interface exposed")
                elif port == 22:
                    risks.append("Medium: SSH exposed")
                elif port in (1900, 5353):
                    risks.append("IoT protocol exposed")
    if not risks:
        risks.append("No major risks detected")
    return risks

# ----------------------
# Subnet detection
# ----------------------
def detect_subnets(devices):
    subnets = set()
    for d in devices:
        try:
            ip = ipaddress.ip_address(d["ip"])
            if ip.is_private:
                net = ipaddress.ip_network(f"{ip}/24", strict=False)
                subnets.add(str(net))
        except Exception:
            pass
    return subnets

# ----------------------
# Per-device processing worker
# ----------------------
def process_device(dev, communications):
    ip = str(dev.get("ip", "Unknown"))
    mac = (dev.get("mac") or "").upper()
    info = dev.get("info") or {}

    vendor = mac_vendor_lookup(mac)
    custom_name = get_custom_name(ip, info)

    role = "Generic Device"
    os_name = "Unknown"
    try:
        if isinstance(info, dict) and "osmatch" in info and info["osmatch"]:
            os_name = info["osmatch"][0].get("name", "Unknown")
        elif isinstance(info, dict) and "osclass" in info and info["osclass"]:
            os_name = info["osclass"][0].get("osfamily", "Unknown")
    except Exception:
        os_name = "Unknown"

    latency = ping_latency_ms(ip)
    latency_str = f"{latency:.1f}" if latency else "N/A"

    risks = analyze_risks(info)
    risks_str = "; ".join(risks)

    ports = []
    try:
        if hasattr(info, "all_protocols"):
            protocols = info.all_protocols()
        elif isinstance(info, dict):
            protocols = list(info.keys())
        else:
            protocols = []
        for proto in protocols:
            proto_ports = info.get(proto, {}) if isinstance(info, dict) else {}
            for p, svc in proto_ports.items():
                svc_name = svc.get("name", "?") if isinstance(svc, dict) else "?"
                ports.append(f"{p}/{proto} ({svc_name})")
    except Exception:
        ports = []

    comms = []
    try:
        if ip in communications:
            for peer in communications[ip]:
                if peer != ip:
                    label = "Internal" if ipaddress.ip_address(peer).is_private else "External"
                    comms.append(f"{peer} [{label}]")
    except Exception:
        comms = []

    return {
        "ip": ip,
        "mac": mac,
        "vendor": vendor,
        "custom_name": custom_name,
        "role": role,
        "os_name": os_name,
        "latency_str": latency_str,
        "ports": ports,
        "risks_str": risks_str,
        "comms_str": ", ".join(comms) if comms else "No traffic observed"
    }

# ----------------------
# Report generation & Excel export
# ----------------------
def generate_report(devices, communications):
    table = Table(title="ZeroTrace Network Report")
    table.add_column("IP", style="cyan")
    table.add_column("MAC", style="magenta")
    table.add_column("Vendor", style="green")
    table.add_column("Custom Name", style="yellow")
    table.add_column("Role", style="blue")
    table.add_column("OS", style="cyan")
    table.add_column("Latency (ms)", style="magenta")
    table.add_column("Risks", style="red")

    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Scan Report"
    ws.append([
        "IP", "MAC", "Vendor", "Custom Name", "Role", "OS", "Latency (ms)",
        "Open Ports", "Risks", "Communications"
    ])

    total = len(devices)
    console.print(f"[cyan]Generating report for {total} devices...[/cyan]")

    with ThreadPoolExecutor(max_workers=CONFIG["device_thread_workers"]) as executor:
        futures = {executor.submit(process_device, dev, communications): dev for dev in devices}
        processed = 0
        for future in as_completed(futures):
            dev = futures[future]
            processed += 1
            try:
                result = future.result(timeout=CONFIG["device_processing_timeout"])
            except TimeoutError:
                result = {
                    "ip": str(dev.get("ip", "Unknown")),
                    "mac": str(dev.get("mac", "")).upper(),
                    "vendor": "Unknown (timeout)",
                    "custom_name": "Unknown",
                    "role": "Unknown",
                    "os_name": "Unknown",
                    "latency_str": "N/A",
                    "ports": [],
                    "risks_str": "Processing timed out",
                    "comms_str": "Unknown"
                }

            table.add_row(
                str(result["ip"]),
                str(result["mac"]),
                str(result["vendor"]),
                str(result["custom_name"]),
                str(result["role"]),
                str(result["os_name"]),
                str(result["latency_str"]),
                str(result["risks_str"])
            )
            ws.append([
                str(result["ip"]),
                str(result["mac"]),
                str(result["vendor"]),
                str(result["custom_name"]),
                str(result["role"]),
                str(result["os_name"]),
                str(result["latency_str"]),
                str(", ".join(result["ports"]) if result["ports"] else "None"),
                str(result["risks_str"]),
                str(result["comms_str"])
            ])
            console.print(f"[blue]✔ Processed {processed}/{total}: {result['ip']}[/blue]")

    # Add Access Point info
    aps = list_access_points()
    cur = current_connection()
    if aps:
        ws_ap = wb.create_sheet("Access Points")
        ws_ap.append(["SSID", "BSSID", "Signal"])
        for ap in aps:
            if "error" in ap:
                ws_ap.append([ap["error"], "", ""])
            else:
                ws_ap.append([ap["ssid"], ap["bssid"], ap["signal"]])
        if cur:
            ws_ap.append([])
            ws_ap.append(["Current Connection"])
            ws_ap.append(["SSID", cur.get("ssid", ""), cur.get("bssid", ""), cur.get("rate", ""), cur.get("signal", "")])

    console.print(table)
    try:
        wb.save(CONFIG["excel_output"])
        console.print(f"[green]✔ Report saved to {os.path.abspath(CONFIG['excel_output'])}[/green]")
    except Exception as e:
        console.print(f"[red]Failed to save Excel file: {e}[/red]")

# ----------------------
# Main
# ----------------------
def main():
    admin = is_admin()
    if admin:
        console.print("[green]✔ Running with administrator privileges[/green]")
    else:
        console.print("[red]✖ Not running as administrator (some features may fail)[/red]")

    mode = console.input("[cyan]Choose scan mode ([b]quick[/b]/[b]deep[/b]): ").strip().lower()
    if mode not in ["quick", "deep"]:
        mode = "quick"

    disc = console.input("[cyan]Discovery method ([b]nmap[/b]/[b]arp[/b]) [nmap]: ").strip().lower() or "nmap"
    if disc not in ["nmap", "arp"]:
        disc = "nmap"

    ssid = get_wifi_ssid()
    console.print(f"[blue]Connected Wi-Fi SSID: {ssid}[/blue]")

    devices = scan_network(mode=mode, discovery_method=disc)
    communications = capture_traffic(duration=CONFIG.get("sniff_seconds", 60))

    subnets = detect_subnets(devices)
    if subnets:
        console.print(f"[cyan]Detected private subnets: {', '.join(sorted(subnets))}[/cyan]")

    console.print("[green]\\n✔ Scan complete. Generating report...[/green]")
    generate_report(devices, communications)

if __name__ == "__main__":
    main()

'''









                                                   # Working Code 
'''

import os
import re
import ipaddress
import platform
import socket
import subprocess
import ctypes
import shutil
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime

import scapy.all as scapy
import nmap
import openpyxl
import requests
from rich.console import Console
from rich.table import Table
from rich.progress import Progress, BarColumn, SpinnerColumn, TimeRemainingColumn

console = Console()

CONFIG = {
    "excel_output": "zerotrace_report.xlsx",
    "device_thread_workers": 20,
}

# ------------------------------------------------------------------------------------
#  LOAD LOCAL OUI FILE
# ------------------------------------------------------------------------------------
OUI_VENDOR_MAP = {}
OUI_FILE_PATH = os.path.join(os.path.dirname(__file__), "oui.txt")

def load_oui_file():
    global OUI_VENDOR_MAP
    if not os.path.exists(OUI_FILE_PATH):
        console.print("[yellow]OUI file not found; vendor lookups may be limited.[/yellow]")
        return
    try:
        with open(OUI_FILE_PATH, "r", encoding="utf-8", errors="ignore") as f:
            for line in f:
                if "(hex)" in line:
                    parts = line.strip().split("(hex)")
                    if len(parts) == 2:
                        prefix = parts[0].strip().replace("-", "").replace(":", "").upper()[:6]
                        vendor = parts[1].strip()
                        if prefix:
                            OUI_VENDOR_MAP[prefix] = vendor
        console.print(f"[green]✔ Loaded {len(OUI_VENDOR_MAP):,} OUIs from oui.txt[/green]")
    except Exception as e:
        console.print(f"[red]Failed to load OUI file: {e}[/red]")

def mac_vendor_lookup(mac):
    if not mac:
        return "Unknown Vendor"
    mac_norm = mac.upper().replace("-", "").replace(":", "")
    prefix = mac_norm[:6]
    if prefix in OUI_VENDOR_MAP:
        return OUI_VENDOR_MAP[prefix]
    try:
        r = requests.get(f"https://api.macvendors.com/{mac}", timeout=3)
        if r.status_code == 200 and r.text.strip():
            return r.text.strip()
    except Exception:
        pass
    return "Unknown Vendor" 

# ------------------------------------------------------------------------------------
#  SYSTEM HELPERS
# ------------------------------------------------------------------------------------
def is_admin():
    try:
        return os.getuid() == 0
    except AttributeError:
        return ctypes.windll.shell32.IsUserAnAdmin() != 0

def get_local_ip():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(("8.8.8.8", 80))
        return s.getsockname()[0]
    except Exception:
        return None
    finally:
        s.close()

# ------------------------------------------------------------------------------------
#  DISCOVERY METHODS
# ------------------------------------------------------------------------------------
def arp_discover(network_cidr):
    console.print(f"[cyan]Running ARP discovery on {network_cidr}...[/cyan]")
    arp = scapy.ARP(pdst=network_cidr)
    broadcast = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
    packet = broadcast / arp
    answered = scapy.srp(packet, timeout=3, verbose=False)[0]
    devices = []
    for _, r in answered:
        devices.append({"ip": r.psrc, "mac": (r.hwsrc or "").upper()})
    console.print(f"[green]ARP discovered {len(devices)} devices[/green]")
    return devices

def nmap_discover(network_cidr):
    nm = nmap.PortScanner()
    if not shutil.which("nmap"):
        console.print("[yellow]nmap not found; using ARP instead.[/yellow]")
        return arp_discover(network_cidr)
    console.print(f"[cyan]Running Nmap discovery on {network_cidr}...[/cyan]")
    nm.scan(hosts=network_cidr, arguments="-sn")
    devices = []
    for host in nm.all_hosts():
        mac = nm[host]["addresses"].get("mac", "").upper() if "addresses" in nm[host] else ""
        devices.append({"ip": host, "mac": mac})
    console.print(f"[green]Nmap discovered {len(devices)} hosts[/green]")
    return devices

# ------------------------------------------------------------------------------------
#  SCAN & CLASSIFICATION
# ------------------------------------------------------------------------------------
def ping_device(ip):
    try:
        out = subprocess.check_output(["ping", "-n", "3", ip], universal_newlines=True, stderr=subprocess.DEVNULL)
        m_avg = re.search(r"Average = (\d+)ms", out)
        m_loss = re.search(r"Lost = \d+, *\( *(\d+)% loss", out)
        latency = float(m_avg.group(1)) if m_avg else None
        loss = float(m_loss.group(1)) if m_loss else None
        return latency, loss
    except Exception:
        return None, None

def nmap_scan_host(ip, mode="quick"):
    nm = nmap.PortScanner()
    try:
        args = "-sS -T4 --top-ports 25" if mode == "quick" else "-sS -sV -O --osscan-guess --top-ports 200 --script vuln"
        nm.scan(ip, arguments=args, timeout=60)
        return nm[ip] if ip in nm.all_hosts() else None
    except Exception:
        return None

def reverse_dns(ip):
    try:
        return socket.gethostbyaddr(ip)[0]
    except Exception:
        return None

def netbios_name(ip):
    """Use Windows nbtstat to get NetBIOS name."""
    try:
        out = subprocess.check_output(["nbtstat", "-A", ip], stderr=subprocess.DEVNULL, universal_newlines=True, timeout=4)
        m = re.search(r"^\s*([A-Z0-9_\-]+)\s+<00>", out, re.MULTILINE)
        if m:
            return m.group(1)
    except Exception:
        pass
    return None

def infer_role(vendor, osname, open_ports):
    v = vendor.lower()
    o = osname.lower()
    ports = set(open_ports)
    if any(p in ports for p in (554, 8554, 8081)) or "camera" in o or "hikvision" in v:
        return "IP Camera"
    if "iphone" in o or "ios" in o or "ipad" in o or "apple" in v:
        return "iPhone/iPad"
    if "android" in o or "samsung" in v or "xiaomi" in v:
        return "Android Phone"
    if any(k in v for k in ("hp", "dell", "lenovo", "microsoft")) or "windows" in o:
        return "Laptop/Desktop"
    if any(p in ports for p in (22, 80, 443)) and "linux" in o:
        return "Server/Linux Host"
    if "roku" in v or "amazon" in v or "chromecast" in v:
        return "Streaming Device"
    if "printer" in v or 9100 in ports:
        return "Printer"
    if any(k in v for k in ("tp-link", "cisco", "netgear", "arris", "eero")):
        return "Router/Switch"
    if any(k in v for k in ("nest", "philips hue", "wyze", "tado", "google nest")):
        return "Smart Home Device"
    return "Generic Device"

def enrich_device(d, mode="quick"):
    ip = d.get("ip")
    mac = d.get("mac", "")
    vendor = mac_vendor_lookup(mac)

    hostname = reverse_dns(ip) or netbios_name(ip) or "Unknown"
    nmdata = nmap_scan_host(ip, mode)
    osname = "Unknown"
    open_ports = []
    vulns = []

    if nmdata:
        if nmdata.get("osmatch"):
            osname = nmdata["osmatch"][0].get("name", "Unknown")
        elif nmdata.get("osclass"):
            osname = nmdata["osclass"][0].get("osfamily", "Unknown")
        tcp = nmdata.get("tcp", {})
        for p, info in tcp.items():
            if info.get("state") == "open":
                open_ports.append(int(p))
        if nmdata.get("hostscript"):
            for s in nmdata["hostscript"]:
                vulns.append(f"{s.get('id')}: {s.get('output')}")

    latency, loss = ping_device(ip)
    role = infer_role(vendor, osname, open_ports)

    return {
        "ip": ip,
        "mac": mac,
        "vendor": vendor,
        "hostname": hostname,
        "os": osname,
        "latency": f"{latency:.1f} ms" if latency else "N/A",
        "packet_loss": f"{loss:.0f}%" if loss else "N/A",
        "open_ports": ", ".join(map(str, open_ports)) if open_ports else "None",
        "role": role,
        "vulnerabilities": "; ".join(vulns) if vulns else "None",
    }

# ------------------------------------------------------------------------------------
#  REPORT
# ------------------------------------------------------------------------------------
def generate_report(devices):
    headers = ["IP", "MAC", "Vendor", "Device Name", "OS", "Role", "Latency", "Packet Loss", "Open Ports", "Vulnerabilities"]
    table = Table(title="ZeroTrace Network Summary", show_lines=False)
    for h in headers:
        table.add_column(h, overflow="fold")

    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Scan Report"
    ws.append(headers)

    for dev in devices:
        row = [
            dev.get("ip", ""),
            dev.get("mac", ""),
            dev.get("vendor", ""),
            dev.get("hostname", ""),
            dev.get("os", ""),
            dev.get("role", ""),
            dev.get("latency", ""),
            dev.get("packet_loss", ""),
            dev.get("open_ports", ""),
            dev.get("vulnerabilities", "")
        ]
        ws.append(row)
        table.add_row(*map(str, row))

    wb.save(CONFIG["excel_output"])
    console.print(table)
    console.print(f"[green]✔ Report saved to {os.path.abspath(CONFIG['excel_output'])}[/green]")

# ------------------------------------------------------------------------------------
#  MAIN
# ------------------------------------------------------------------------------------
def main():
    console.print("[bold cyan]ZeroTrace Enterprise Network Scanner[/bold cyan]")
    load_oui_file()

    mode = console.input("[cyan]Scan mode ([b]quick[/b]/[b]deep[/b]/[b]both[/b]): ").strip().lower() or "quick"
    disc = console.input("[cyan]Discovery method ([b]nmap[/b]/[b]arp[/b]/[b]both[/b]) [nmap]: ").strip().lower() or "nmap"

    local_ip = get_local_ip()
    if not local_ip:
        console.print("[red]Could not determine local IP address.[/red]")
        return
    network_cidr = str(ipaddress.ip_network(f"{local_ip}/24", strict=False))
    console.print(f"[blue]Scanning subnet: {network_cidr}[/blue]")

    if disc == "arp":
        devices = arp_discover(network_cidr)
    elif disc == "nmap":
        devices = nmap_discover(network_cidr)
    else:
        arp_list = arp_discover(network_cidr)
        nmap_list = nmap_discover(network_cidr)
        ipmap = {d["ip"]: d for d in arp_list}
        for n in nmap_list:
            if n["ip"] not in ipmap:
                ipmap[n["ip"]] = n
            elif not ipmap[n["ip"]].get("mac"):
                ipmap[n["ip"]]["mac"] = n.get("mac", "")
        devices = list(ipmap.values())

    if not devices:
        console.print("[red]No devices discovered.[/red]")
        return

    console.print(f"[cyan]Discovered {len(devices)} devices — scanning in {mode} mode...[/cyan]")
    enriched = []
    with Progress(SpinnerColumn(), "[progress.description]{task.description}", BarColumn(), "{task.completed}/{task.total}", TimeRemainingColumn()) as progress:
        task = progress.add_task("Scanning devices", total=len(devices))
        with ThreadPoolExecutor(max_workers=CONFIG["device_thread_workers"]) as ex:
            futures = {ex.submit(enrich_device, d, "deep" if mode in ("deep", "both") else "quick"): d for d in devices}
            for f in as_completed(futures):
                try:
                    enriched.append(f.result())
                except Exception:
                    enriched.append(futures[f])
                progress.update(task, advance=1)

    generate_report(enriched)

if __name__ == "__main__":
    main()

'''









                                                                                        #---------------------------------------------------------------------------------------------------------------------------
                                                       # Adds confidence score                          
'''
import os
import re
import ipaddress
import platform
import socket
import subprocess
import ctypes
import shutil
import json
from datetime import datetime
from collections import Counter, defaultdict
from concurrent.futures import ThreadPoolExecutor, as_completed

# Third-party libs (must be installed)
import scapy.all as scapy
import nmap
import openpyxl
import requests
from rich.console import Console
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, BarColumn, TimeRemainingColumn

console = Console()

# ---------------------------
# Config
# ---------------------------
CONFIG = {
    "excel_output": "zerotrace_report.xlsx",
    "device_thread_workers": 20,
    "scan_thread_workers": 30,
    "ping_count": 3,
    "nmap_timeout": 60,         # per-host timeout for nmap
    "max_service_version_len": 120
}

# ---------------------------
# OUI vendor map loading
# ---------------------------
OUI_VENDOR_MAP = {}
OUI_FILE_PATH = os.path.join(os.path.dirname(__file__), "oui.txt")

def load_oui_file():
    """Load IEEE OUI file (standards-oui.ieee.org format)."""
    global OUI_VENDOR_MAP
    if not os.path.exists(OUI_FILE_PATH):
        console.print("[yellow]oui.txt not found — vendor lookups may be limited.[/yellow]")
        return
    try:
        count = 0
        with open(OUI_FILE_PATH, "r", encoding="utf-8", errors="ignore") as f:
            for line in f:
                # typical IEEE format: "00-11-22   (hex)    Vendor Name"
                if "(hex)" in line:
                    parts = line.strip().split("(hex)")
                    if len(parts) == 2:
                        prefix = parts[0].strip().replace("-", "").replace(":", "").upper()[:6]
                        vendor = parts[1].strip()
                        if prefix:
                            OUI_VENDOR_MAP[prefix] = vendor
                            count += 1
        console.print(f"[green]✔ Loaded {count:,} OUIs from oui.txt[/green]")
    except Exception as e:
        console.print(f"[red]Failed to load OUI file: {e}[/red]")

def mac_vendor_lookup(mac: str) -> tuple[str, int]:
    """
    Return (vendor_name, confidence_percent).
    Confidence:
      - 95-100%: matched via local OUI file
      - 80%: matched via external API
      - 30-50%: heuristics (partial match)
      - 0%: unknown
    """
    if not mac:
        return ("Unknown Vendor", 0)
    mac_norm = mac.upper().replace(":", "").replace("-", "")
    prefix = mac_norm[:6]
    vendor = OUI_VENDOR_MAP.get(prefix)
    if vendor:
        return (vendor, 98)
    # try external API
    try:
        r = requests.get(f"https://api.macvendors.com/{mac}", timeout=3)
        if r.status_code == 200 and r.text.strip():
            return (r.text.strip(), 80)
    except Exception:
        pass
    # heuristic: try partial OUI match (first 5 hex chars) maybe lower confidence
    try:
        for k, v in OUI_VENDOR_MAP.items():
            if mac_norm.startswith(k[:5]):
                return (v, 40)
    except Exception:
        pass
    return ("Unknown Vendor", 0)

# ---------------------------
# System / Network helpers
# ---------------------------
def is_admin() -> bool:
    try:
        return os.getuid() == 0
    except AttributeError:  # windows
        try:
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        except Exception:
            return False

def get_local_ip() -> str | None:
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(("8.8.8.8", 80))
        return s.getsockname()[0]
    except Exception:
        return None
    finally:
        s.close()

def get_wifi_ssid() -> str | None:
    """Return SSID if connected to Wi-Fi on Windows (or Linux)."""
    try:
        system = platform.system().lower()
        if system == "windows":
            out = subprocess.check_output("netsh wlan show interfaces", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL)
            m = re.search(r"SSID\s*:\s(.+)", out)
            return m.group(1).strip() if m else None
        else:
            out = subprocess.check_output("iwgetid -r", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL)
            s = out.strip()
            return s or None
    except Exception:
        return None

def get_connection_type() -> str:
    """Naive check: if SSID present => Wi-Fi, else check ethernet state on Windows."""
    try:
        ssid = get_wifi_ssid()
        if ssid:
            return "Wi-Fi"
        system = platform.system().lower()
        if system == "windows":
            out = subprocess.check_output("netsh interface show interface", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL)
            if "Ethernet" in out and "Connected" in out:
                return "Ethernet"
    except Exception:
        pass
    return "Unknown"

# ---------------------------
# Discovery methods
# ---------------------------
def arp_discover(network_cidr: str):
    console.print(f"[cyan]Running ARP discovery on {network_cidr}...[/cyan]")
    arp = scapy.ARP(pdst=network_cidr)
    ether = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
    packet = ether/arp
    try:
        answered = scapy.srp(packet, timeout=3, verbose=False)[0]
    except Exception as e:
        console.print(f"[yellow]ARP failed: {e}[/yellow]")
        return []
    devices = []
    for _, r in answered:
        devices.append({"ip": r.psrc, "mac": (r.hwsrc or "").upper(), "info": None})
    console.print(f"[green]ARP discovered {len(devices)} devices[/green]")
    return devices

def nmap_discover(network_cidr: str):
    nm = nmap.PortScanner()
    if not shutil.which("nmap"):
        console.print("[yellow]nmap binary not found — falling back to ARP[/yellow]")
        return arp_discover(network_cidr)
    console.print(f"[cyan]Running nmap discovery (-sn) on {network_cidr}...[/cyan]")
    try:
        nm.scan(hosts=network_cidr, arguments="-sn")
        devices = []
        for host in nm.all_hosts():
            mac = ""
            try:
                mac = nm[host]["addresses"].get("mac", "").upper()
            except Exception:
                mac = ""
            devices.append({"ip": host, "mac": mac, "info": nm[host]})
        console.print(f"[green]nmap discovered {len(devices)} hosts[/green]")
        return devices
    except Exception as e:
        console.print(f"[yellow]nmap discovery error: {e} — using ARP[/yellow]")
        return arp_discover(network_cidr)

# ---------------------------
# Per-host nmap wrapper (for deeper enrichment)
# ---------------------------
def nmap_scan_host(ip: str, mode: str = "quick"):
    """Return parsed host object (or None). mode 'deep' uses version/os/vuln scripts."""
    nm = nmap.PortScanner()
    try:
        if mode == "quick":
            args = "-sS -T4 --top-ports 20 -Pn"
        else:
            # deep includes service/version, OS/fingerprinting and vuln scripts
            args = "-sS -sV -O --osscan-guess --top-ports 200 --script vuln -Pn"
        nm.scan(ip, arguments=args, timeout=CONFIG["nmap_timeout"])
        if ip in nm.all_hosts():
            return nm[ip]
        return None
    except Exception as e:
        # nmap may raise on permissions or timeout
        # return None, caller will handle
        return None

# ---------------------------
# Ping helpers (latency + packet loss + ttl)
# ---------------------------
def ping_device(ip: str, count: int = None):
    """Return (avg_ms, loss_percent, ttl) or (None, None, None). Windows-style ping parsing used."""
    if count is None:
        count = CONFIG["ping_count"]
    system = platform.system().lower()
    if system == "windows":
        cmd = ["ping", "-n", str(count), ip]
    else:
        cmd = ["ping", "-c", str(count), ip]
    try:
        out = subprocess.check_output(cmd, stderr=subprocess.DEVNULL, universal_newlines=True, timeout=15)
    except Exception:
        return (None, None, None)
    avg = None
    loss = None
    ttl = None
    # Windows parse
    if system == "windows":
        m_avg = re.search(r"Average = (\d+)ms", out)
        m_loss = re.search(r"Lost = \d+.*,\s+(\d+)% loss", out) or re.search(r"Lost = \d+.*,\s+Lost% = (\d+)%", out)
        m_ttl = re.search(r"TTL=(\d+)", out)
        if m_avg:
            try:
                avg = float(m_avg.group(1))
            except Exception:
                avg = None
        if m_loss:
            try:
                loss = float(m_loss.group(1))
            except Exception:
                loss = None
        if m_ttl:
            try:
                ttl = int(m_ttl.group(1))
            except Exception:
                ttl = None
    else:
        m_avg = re.search(r"rtt [\w/]+ = [\d\.]+/([\d\.]+)/", out)
        m_loss = re.search(r"(\d+)% packet loss", out)
        m_ttl = re.search(r"time=(?:[\d\.]+) ms\s+ttl=(\d+)", out) or re.search(r"ttl=(\d+)", out)
        if m_avg:
            try:
                avg = float(m_avg.group(1))
            except Exception:
                avg = None
        if m_loss:
            try:
                loss = float(m_loss.group(1))
            except Exception:
                loss = None
        if m_ttl:
            try:
                ttl = int(m_ttl.group(1))
            except Exception:
                ttl = None
    return (avg, loss, ttl)

# ---------------------------
# Role & OS inference + confidence scoring
# ---------------------------
def infer_role_and_confidence(vendor: str, os_name: str, open_ports: list, ttl: int | None) -> tuple[str, int]:
    """
    Heuristic role inference using vendor, OS, ports, TTL.
    Returns (role, confidence_percent)
    """
    v = (vendor or "").lower()
    o = (os_name or "").lower()
    ports = set(open_ports or [])
    score = 40  # base

    # strong indicators
    if any(p in ports for p in (554, 8554, 5544)) or "camera" in o or "hikvision" in v or "axis" in v:
        return ("IP Camera", 95)
    if "printer" in v or 9100 in ports:
        return ("Printer", 93)
    if any(k in v for k in ("roku", "amazon", "chromecast", "philips")) or "smarttv" in o or "tv" in o:
        return ("Smart TV / Streaming Device", 90)
    if any(k in v for k in ("apple",)) or "ios" in o or "iphone" in o or "ipad" in o:
        return ("Phone / Tablet (Apple)", 92)
    if any(k in v for k in ("samsung", "xiaomi", "huawei")) or "android" in o:
        return ("Phone / Tablet (Android)", 88)
    if any(k in v for k in ("cisco", "juniper", "netgear", "tp-link", "arris", "eero", "luxul", "ubiquiti")):
        return ("Router / Switch", 92)
    if "windows" in o or any(k in v for k in ("dell", "hp", "lenovo", "microsoft")):
        return ("Laptop / Desktop (Windows)", 85)
    if "mac os" in o or "darwin" in o or any(k in v for k in ("apple")) and "iphone" not in o:
        return ("Mac / macOS", 88)
    if "linux" in o or any(k in v for k in ("raspberry", "ubuntu", "debian", "centos", "red hat", "redhat")):
        # server vs IoT — if ports suggest server
        if any(p in ports for p in (22, 80, 443, 3306, 5432)):
            return ("Server / Linux Host", 90)
        return ("Linux / Embedded", 75)

    # TTL heuristics: many routers reply with TTL high/low? (weak)
    if ttl is not None:
        if ttl <= 64:
            score += 5
        elif ttl > 128:
            score += 3

    # port-based signals
    if 22 in ports and not (80 in ports or 443 in ports):
        return ("SSH Host / Appliance", 80)
    if 80 in ports or 443 in ports:
        return ("Web-Connected Device", 70)

    # fallback
    return ("Generic Device", min(95, score))

def os_confidence_from_nmap(nmap_host):
    """Return (os_guess, confidence). Heuristics: prefer nmap osmatch if present."""
    if not nmap_host:
        return ("Unknown", 0)
    try:
        # python-nmap exposes 'osmatch' as list
        osmatch = nmap_host.get("osmatch", [])
        if osmatch:
            name = osmatch[0].get("name", "Unknown")
            # nmap produces a 'accuracy' field sometimes
            acc = osmatch[0].get("accuracy")
            try:
                conf = int(acc) if acc is not None else 85
            except Exception:
                conf = 85
            return (name, conf)
        # fallback to osclass
        osclass = nmap_host.get("osclass", [])
        if osclass:
            fam = osclass[0].get("osfamily") or osclass[0].get("osgen") or "Unknown"
            conf = osclass[0].get("accuracy") or 70
            try:
                conf = int(conf)
            except Exception:
                conf = 70
            return (fam, conf)
    except Exception:
        pass
    return ("Unknown", 0)

# ---------------------------
# Vulnerability extraction helpers
# ---------------------------
CVE_RE = re.compile(r"(CVE-\d{4}-\d{4,7})", re.IGNORECASE)

def parse_nmap_scripts_for_cves(nmap_host):
    """Extract CVE IDs and short descriptions from nmap hostscript output (if present)."""
    results = []
    # hostscript is usually list of dict { 'id': 'vuln', 'output': '... CVE-...' }
    try:
        hostscript = nmap_host.get("hostscript", []) if nmap_host else []
    except Exception:
        hostscript = []
    for s in hostscript:
        out = (s.get("output") or "")
        # find CVE tokens
        cves = CVE_RE.findall(out)
        if cves:
            for cve in sorted(set(cves)):
                # extract small snippet containing cve
                m = re.search(r".{0,80}"+re.escape(cve)+r".{0,80}", out, re.IGNORECASE)
                snippet = m.group(0).strip() if m else out[:120].strip()
                # form "CVE-xxxx-xxxx - snippet" (normalize newlines safely)
                snippet_clean = snippet.replace("\n", " ").strip()
                readable = f"{cve} - {snippet_clean}"
                results.append(readable)
        else:
            # sometimes script output names a CVE-like description
            if len(out) > 10:
                results.append(out.strip()[:200])
    # also check scripts listed in 'script' keys in services
    try:
        services = nmap_host.get("tcp", {}) if nmap_host else {}
        for port, svc in services.items():
            scripts = svc.get("script", {}) if isinstance(svc.get("script", {}), dict) else svc.get("script", [])
            # script may be dict or list
            if isinstance(scripts, dict):
                for k, v in scripts.items():
                    text = v if isinstance(v, str) else str(v)
                    cves = CVE_RE.findall(text)
                    if cves:
                        for cve in sorted(set(cves)):
                            m = re.search(r".{0,80}"+re.escape(cve)+r".{0,80}", text, re.IGNORECASE)
                            snippet = m.group(0).strip() if m else text[:120].strip()
                            snippet_clean = snippet.replace("\n", " ").strip()
                            results.append(f"{cve} - {snippet_clean}")
                    elif text:
                        results.append(text.strip()[:200])
            elif isinstance(scripts, list):
                for item in scripts:
                    text = item.get("output") if isinstance(item, dict) else str(item)
                    cves = CVE_RE.findall(text)
                    if cves:
                        for cve in sorted(set(cves)):
                            m = re.search(r".{0,80}"+re.escape(cve)+r".{0,80}", text, re.IGNORECASE)
                            snippet = m.group(0).strip() if m else text[:120].strip()
                            snippet_clean = snippet.replace("\n", " ").strip()
                            results.append(f"{cve} - {snippet_clean}")
                    elif text:
                        results.append(text.strip()[:200])
    except Exception:
        pass

    # dedupe & limit
    seen = []
    for r in results:
        if r not in seen:
            seen.append(r)
    return seen[:10]

# ---------------------------
# Service versions summarization
# ---------------------------
def summarize_service_versions(nmap_host):
    """Return short summary string of services/products and versions."""
    if not nmap_host:
        return "None"
    services = []
    try:
        tcp = nmap_host.get("tcp", {}) or {}
        for port_s, info in tcp.items():
            try:
                port = int(port_s)
            except Exception:
                continue
            state = info.get("state", "")
            if state != "open":
                continue
            name = info.get("name") or ""
            product = info.get("product") or ""
            version = info.get("version") or ""
            extr = f"{product} {version}".strip()
            if extr:
                services.append(f"{port}/{name} ({extr})")
            else:
                services.append(f"{port}/{name}")
    except Exception:
        pass
    if not services:
        return "None"
    joined = "; ".join(services)
    if len(joined) > CONFIG["max_service_version_len"]:
        joined = joined[:CONFIG["max_service_version_len"]-3] + "..."
    return joined

# ---------------------------
# Per-device enrichment
# ---------------------------
def enrich_device(device: dict, mode: str = "quick"):
    ip = device.get("ip")
    mac = device.get("mac") or ""
    result = {
        "ip": ip,
        "mac": mac,
        "vendor": "Unknown",
        "vendor_conf": 0,
        "hostname": "",
        "os": "Unknown",
        "os_conf": 0,
        "role": "Generic Device",
        "role_conf": 0,
        "latency_ms": "N/A",
        "packet_loss": "N/A",
        "ttl": None,
        "open_ports": "None",
        "services": "None",
        "vulnerabilities": "None",
        "discovered_at": datetime.utcnow().isoformat() + "Z",
        "last_seen_at": datetime.utcnow().isoformat() + "Z"
    }

    # vendor
    try:
        vendor, vconf = mac_vendor_lookup(mac)
        result["vendor"] = vendor
        result["vendor_conf"] = vconf
    except Exception:
        pass

    # ping
    try:
        avg, loss, ttl = ping_device(ip)
        result["latency_ms"] = f"{avg:.1f} ms" if avg is not None else "N/A"
        result["packet_loss"] = f"{loss:.0f}%" if loss is not None else "N/A"
        result["ttl"] = ttl
    except Exception:
        pass

    # nmap deep/quick
    ndata = None
    try:
        ndata = nmap_scan_host(ip, mode)
    except Exception:
        ndata = None

    # OS guess & confidence
    try:
        os_guess, os_conf = os_confidence_from_nmap(ndata)
        result["os"] = os_guess or "Unknown"
        result["os_conf"] = os_conf or 0
    except Exception:
        pass

    # open ports & service versions
    try:
        sv = summarize_service_versions(ndata)
        result["services"] = sv
        # build open ports list
        open_ports = []
        if ndata:
            tcp = ndata.get("tcp", {}) or {}
            for p, info in tcp.items():
                try:
                    if info.get("state") == "open":
                        open_ports.append(int(p))
                except Exception:
                    continue
        result["open_ports"] = ", ".join(map(str, sorted(open_ports))) if open_ports else "None"
    except Exception:
        pass

    # vulnerabilities / CVEs
    try:
        cves = parse_nmap_scripts_for_cves(ndata)
        if cves:
            result["vulnerabilities"] = "; ".join(cves)
        else:
            # heuristics: if dangerous ports open, flag potential issues
            op = [int(p) for p in (result["open_ports"].split(", ") if result["open_ports"] and result["open_ports"] != "None" else []) if p]
            weak_ports = []
            if 23 in op:
                weak_ports.append("Telnet open (plaintext)")
            if 21 in op:
                weak_ports.append("FTP open (plaintext)")
            if 445 in op:
                weak_ports.append("SMB exposed")
            if weak_ports:
                result["vulnerabilities"] = "; ".join(weak_ports)
    except Exception:
        pass

    # hostname
    try:
        hostname = None
        try:
            hostname = socket.gethostbyaddr(ip)[0]
        except Exception:
            hostname = None
        # netbios fallback (Windows)
        if not hostname:
            try:
                nb = subprocess.check_output(["nbtstat", "-A", ip], universal_newlines=True, stderr=subprocess.DEVNULL, timeout=3)
                m = re.search(r"^\s*([A-Z0-9_\-]+)\s+<00>", nb, re.MULTILINE)
                if m:
                    hostname = m.group(1)
            except Exception:
                hostname = hostname
        result["hostname"] = hostname or ip
    except Exception:
        result["hostname"] = ip

    # infer role with confidence
    try:
        open_ports_list = []
        if result["open_ports"] and result["open_ports"] != "None":
            open_ports_list = [int(p) for p in result["open_ports"].split(",") if p and p.strip().isdigit()]
        role, rconf = infer_role_and_confidence(result["vendor"], result["os"], open_ports_list, result["ttl"])
        result["role"] = role
        result["role_conf"] = rconf
    except Exception:
        result["role"] = "Generic Device"
        result["role_conf"] = 30

    return result

# ---------------------------
# Parallel enrichment wrapper
# ---------------------------
def enrich_devices(devices: list, mode: str):
    enriched = []
    with ThreadPoolExecutor(max_workers=CONFIG["device_thread_workers"]) as ex:
        futures = {ex.submit(enrich_device, d, mode): d for d in devices}
        with Progress(SpinnerColumn(), "[progress.description]{task.description}", BarColumn(), "{task.completed}/{task.total}", TimeRemainingColumn()) as prog:
            task = prog.add_task("Enriching devices", total=len(futures))
            for fut in as_completed(futures):
                try:
                    enriched.append(fut.result())
                except Exception:
                    enriched.append(futures[fut])
                prog.update(task, advance=1)
    return enriched

# ---------------------------
# Export helpers (Excel/CSV/JSON)
# ---------------------------
def save_excel(devices: list, path: str):
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Scan Report"
    headers = [
        "IP", "MAC", "Vendor", "Vendor_Confidence", "Hostname",
        "OS", "OS_Confidence", "Role", "Role_Confidence",
        "Latency_ms", "Packet_Loss", "Open_Ports", "Services",
        "Vulnerabilities", "Discovered_At", "Last_Seen"
    ]
    ws.append(headers)
    for d in devices:
        row = [
            d.get("ip"), d.get("mac"), d.get("vendor"), d.get("vendor_conf"),
            d.get("hostname"), d.get("os"), d.get("os_conf"),
            d.get("role"), d.get("role_conf"),
            d.get("latency_ms"), d.get("packet_loss"),
            d.get("open_ports"), d.get("services"),
            d.get("vulnerabilities"), d.get("discovered_at"), d.get("last_seen_at")
        ]
        ws.append(row)

    # Access Points sheet
    try:
        aps = list_access_points()
        if aps:
            ws_ap = wb.create_sheet("Access Points")
            ws_ap.append(["SSID", "BSSID", "Signal", "Type"])
            ssid_groups = defaultdict(list)
            for ap in aps:
                ssid = ap.get("ssid") or "Unknown"
                ssid_groups[ssid].append(ap)
            for ap in aps:
                ssid = ap.get("ssid") or "Unknown"
                typ = "Mesh/Extender" if len(ssid_groups[ssid]) > 1 else "Primary"
                ws_ap.append([ap.get("ssid"), ap.get("bssid"), ap.get("signal"), typ])
            # If current connection, add
            cur = current_connection()
            if cur:
                ws_ap.append([])
                ws_ap.append(["Current Connection"])
                ws_ap.append(["SSID", cur.get("ssid"), cur.get("bssid"), cur.get("rate"), cur.get("signal")])
    except Exception:
        pass

    wb.save(path)
    console.print(f"[green]✔ Excel saved to {os.path.abspath(path)}[/green]")

def save_csv(devices: list, path: str):
    import csv
    headers = [
        "IP", "MAC", "Vendor", "Vendor_Confidence", "Hostname",
        "OS", "OS_Confidence", "Role", "Role_Confidence",
        "Latency_ms", "Packet_Loss", "Open_Ports", "Services",
        "Vulnerabilities", "Discovered_At", "Last_Seen"
    ]
    with open(path, "w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(headers)
        for d in devices:
            w.writerow([
                d.get("ip"), d.get("mac"), d.get("vendor"), d.get("vendor_conf"),
                d.get("hostname"), d.get("os"), d.get("os_conf"),
                d.get("role"), d.get("role_conf"),
                d.get("latency_ms"), d.get("packet_loss"),
                d.get("open_ports"), d.get("services"),
                d.get("vulnerabilities"), d.get("discovered_at"), d.get("last_seen_at")
            ])
    console.print(f"[green]✔ CSV saved to {os.path.abspath(path)}[/green]")

def save_json(devices: list, path: str):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(devices, f, indent=2)
    console.print(f"[green]✔ JSON saved to {os.path.abspath(path)}[/green]")

# ---------------------------
# Wi-Fi/AP helpers (Windows-focused)
# ---------------------------
def list_access_points():
    system = platform.system().lower()
    aps = []
    try:
        if system == "windows":
            out = subprocess.check_output("netsh wlan show networks mode=bssid", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL)
            ssid = None
            bssid = None
            signal = None
            for line in out.splitlines():
                if "SSID" in line and "BSSID" not in line:
                    ssid = line.split(":", 1)[1].strip()
                elif "BSSID" in line:
                    bssid = line.split(":", 1)[1].strip()
                elif "Signal" in line:
                    signal = line.split(":", 1)[1].strip()
                    if ssid and bssid:
                        aps.append({"ssid": ssid, "bssid": bssid, "signal": signal})
        else:
            out = subprocess.check_output("nmcli -t -f SSID,BSSID,SIGNAL dev wifi", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL)
            for line in out.strip().split("\n"):
                parts = line.split(":")
                if len(parts) >= 3:
                    aps.append({"ssid": parts[0], "bssid": parts[1], "signal": parts[2]})
    except Exception:
        pass
    return aps

def current_connection():
    system = platform.system().lower()
    if system == "windows":
        try:
            out = subprocess.check_output("netsh wlan show interfaces", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL)
            ssid = re.search(r"SSID\s*:\s(.+)", out)
            bssid = re.search(r"BSSID\s*:\s(.+)", out)
            rate = re.search(r"Receive rate \(Mbps\)\s*:\s(.+)", out)
            signal = re.search(r"Signal\s*:\s(.+)", out)
            return {
                "ssid": ssid.group(1).strip() if ssid else None,
                "bssid": bssid.group(1).strip() if bssid else None,
                "rate": rate.group(1).strip() if rate else None,
                "signal": signal.group(1).strip() if signal else None
            }
        except Exception:
            return None
    else:
        try:
            out = subprocess.check_output("iw dev wlan0 link", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL)
            ssid = re.search(r"SSID: (.+)", out)
            bssid = re.search(r"Connected to (.+)", out)
            rate = re.search(r"tx bitrate: (.+)", out)
            return {
                "ssid": ssid.group(1).strip() if ssid else None,
                "bssid": bssid.group(1).strip() if bssid else None,
                "rate": rate.group(1).strip() if rate else None
            }
        except Exception:
            return None

# ---------------------------
# Main: Orchestration
# ---------------------------
def main():
    console.print("[bold cyan]ZeroTrace Enhanced Scanner — v4[/bold cyan]")
    admin = is_admin()
    if admin:
        console.print("[green]✔ Running with administrator privileges[/green]")
    else:
        console.print("[yellow]⚠ Not running as administrator — some scans (OS detection / vuln scripts) may be limited.[/yellow]")

    load_oui_file()

    conn_type = get_connection_type()
    ssid = get_wifi_ssid() if conn_type == "Wi-Fi" else None
    console.print(f"[blue]Connection type:[/] {conn_type}")
    if ssid:
        console.print(f"[blue]Connected SSID:[/] {ssid}")

    # choose quick/deep/both
    mode = console.input("[cyan]Scan mode ([b]quick[/b]/[b]deep[/b]/[b]both[/b]) [quick]: ").strip().lower() or "quick"
    while mode not in ("quick", "deep", "both"):
        mode = console.input("[cyan]Choose 'quick', 'deep' or 'both': ").strip().lower()

    # choose discovery
    disc = console.input("[cyan]Discovery method ([b]nmap[/b]/[b]arp[/b]/[b]both[/b]) [nmap]: ").strip().lower() or "nmap"
    while disc not in ("nmap", "arp", "both"):
        disc = console.input("[cyan]Choose 'nmap', 'arp' or 'both': ").strip().lower()

    # choose export type (default excel)
    export_choice = console.input("[cyan]Export format ([b]excel[/b]/[b]csv[/b]/[b]json) [excel]: ").strip().lower() or "excel"
    while export_choice not in ("excel", "csv", "json"):
        export_choice = console.input("[cyan]Choose 'excel', 'csv' or 'json': ").strip().lower()

    local_ip = get_local_ip()
    if not local_ip:
        console.print("[red]Could not determine local IP address — aborting.[/red]")
        return
    network_cidr = str(ipaddress.ip_network(f"{local_ip}/24", strict=False))
    console.print(f"[blue]Scanning subnet: {network_cidr}[/blue]")

    # discovery phase
    discovered = []
    if disc == "arp":
        discovered = arp_discover(network_cidr)
    elif disc == "nmap":
        discovered = nmap_discover(network_cidr)
    else:
        arp_list = arp_discover(network_cidr)
        nmap_list = nmap_discover(network_cidr)
        ipmap = {}
        for d in arp_list:
            ipmap[d["ip"]] = d
        for n in nmap_list:
            if n["ip"] not in ipmap:
                ipmap[n["ip"]] = n
            else:
                # prefer mac if missing
                if not ipmap[n["ip"]].get("mac") and n.get("mac"):
                    ipmap[n["ip"]]["mac"] = n.get("mac")
        discovered = list(ipmap.values())

    if not discovered:
        console.print("[red]No devices discovered.[/red]")
        return

    # scanning mode: if 'both', do quick discovery then deep enrichment (we pass mode accordingly)
    nmap_mode = "deep" if mode in ("deep", "both") else "quick"

    console.print(f"[cyan]Discovered {len(discovered)} devices — enriching (mode={nmap_mode})...[/cyan]")

    devices_enriched = enrich_devices(discovered, nmap_mode)

    # timestamp last seen/update
    ts = datetime.utcnow().isoformat() + "Z"
    for d in devices_enriched:
        d["last_seen_at"] = ts

    # Show table summary
    headers = ["IP", "Name", "Vendor (conf)", "OS (conf)", "Role (conf)", "Latency", "Packet Loss", "Open Ports", "Vulns"]
    tbl = Table(title="ZeroTrace Network Summary (preview)", show_lines=False)
    for h in headers:
        tbl.add_column(h, overflow="fold")
    for d in devices_enriched:
        vendor_conf = f"{d.get('vendor')} ({d.get('vendor_conf',0)}%)"
        os_conf = f"{d.get('os')} ({d.get('os_conf',0)}%)"
        role_conf = f"{d.get('role')} ({d.get('role_conf',0)}%)"
        tbl.add_row(
            str(d.get("ip") or ""),
            str(d.get("hostname") or ""),
            vendor_conf,
            os_conf,
            role_conf,
            str(d.get("latency_ms") or ""),
            str(d.get("packet_loss") or ""),
            str(d.get("open_ports") or ""),
            str(d.get("vulnerabilities") or "")
        )
    console.print(tbl)

    # Save report (default Excel in same folder)
    outname = CONFIG["excel_output"]
    if export_choice == "excel":
        save_excel(devices_enriched, outname)
    elif export_choice == "csv":
        outcsv = os.path.splitext(outname)[0] + ".csv"
        save_csv(devices_enriched, outcsv)
    else:
        outjson = os.path.splitext(outname)[0] + ".json"
        save_json(devices_enriched, outjson)

    console.print("[green]Done.[/green]")

if __name__ == "__main__":
    main()

                                                #---------------------------------------------------------------------------------------------------------------------------

'''



import os
import re
import ipaddress
import platform
import socket
import subprocess
import ctypes
import shutil
import json
from datetime import datetime
from collections import Counter, defaultdict
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Optional

# Third-party libs (must be installed)
import scapy.all as scapy
import nmap
import openpyxl
import requests
from rich.console import Console
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, BarColumn, TimeRemainingColumn

console = Console()

# ---------------------------
# Config
# ---------------------------
CONFIG = {
    "excel_output": "zerotrace_report.xlsx",
    "device_thread_workers": 20,
    "scan_thread_workers": 30,
    "ping_count": 3,
    "nmap_timeout": 60,         # per-host timeout for nmap
    "max_service_version_len": 120
}

# ---------------------------
# OUI vendor map loading
# ---------------------------
OUI_VENDOR_MAP = {}
OUI_FILE_PATH = os.path.join(os.path.dirname(__file__), "oui.txt")

def load_oui_file():
    """Load IEEE OUI file (standards-oui.ieee.org format)."""
    global OUI_VENDOR_MAP
    if not os.path.exists(OUI_FILE_PATH):
        console.print("[yellow]oui.txt not found — vendor lookups may be limited.[/yellow]")
        return
    try:
        count = 0
        with open(OUI_FILE_PATH, "r", encoding="utf-8", errors="ignore") as f:
            for line in f:
                # typical IEEE format: "00-11-22   (hex)    Vendor Name"
                if "(hex)" in line:
                    parts = line.strip().split("(hex)")
                    if len(parts) == 2:
                        prefix = parts[0].strip().replace("-", "").replace(":", "").upper()[:6]
                        vendor = parts[1].strip()
                        if prefix:
                            OUI_VENDOR_MAP[prefix] = vendor
                            count += 1
        console.print(f"[green]✔ Loaded {count:,} OUIs from oui.txt[/green]")
    except Exception as e:
        console.print(f"[red]Failed to load OUI file: {e}[/red]")

def mac_vendor_lookup(mac: str) -> tuple[str, int]:
    """
    Return (vendor_name, confidence_percent).
    Confidence:
      - 95-100%: matched via local OUI file
      - 80%: matched via external API
      - 30-50%: heuristics (partial match)
      - 0%: unknown
    """
    if not mac:
        return ("Unknown Vendor", 0)
    mac_norm = mac.upper().replace(":", "").replace("-", "")
    prefix = mac_norm[:6]
    vendor = OUI_VENDOR_MAP.get(prefix)
    if vendor:
        return (vendor, 98)
    # try external API
    try:
        r = requests.get(f"https://api.macvendors.com/{mac}", timeout=3)
        if r.status_code == 200 and r.text.strip():
            return (r.text.strip(), 80)
    except Exception:
        pass
    # heuristic: try partial OUI match (first 5 hex chars) maybe lower confidence
    try:
        for k, v in OUI_VENDOR_MAP.items():
            if mac_norm.startswith(k[:5]):
                return (v, 40)
    except Exception:
        pass
    return ("Unknown Vendor", 0)

# ---------------------------
# System / Network helpers
# ---------------------------
def is_admin() -> bool:
    try:
        return os.getuid() == 0
    except AttributeError:  # windows
        try:
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        except Exception:
            return False
def get_local_ip() -> Optional[str]:
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(("8.8.8.8", 80))
        return s.getsockname()[0]
    except Exception:
        return None
    finally:
        s.close()
        s.close()

def get_wifi_ssid() -> Optional[str]:
    """Return SSID if connected to Wi-Fi on Windows (or Linux)."""
    try:
        system = platform.system().lower()
        if system == "windows":
            out = subprocess.check_output("netsh wlan show interfaces", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL)
            m = re.search(r"SSID\s*:\s(.+)", out)
            return m.group(1).strip() if m else None
        else:
            out = subprocess.check_output("iwgetid -r", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL)
            s = out.strip()
            return s or None
    except Exception:
        return None

def get_connection_type() -> str:
    """Naive check: if SSID present => Wi-Fi, else check ethernet state on Windows."""
    try:
        ssid = get_wifi_ssid()
        if ssid:
            return "Wi-Fi"
        system = platform.system().lower()
        if system == "windows":
            out = subprocess.check_output("netsh interface show interface", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL)
            if "Ethernet" in out and "Connected" in out:
                return "Ethernet"
    except Exception:
        pass
    return "Unknown"

# ---------------------------
# Discovery methods
# ---------------------------
def arp_discover(network_cidr: str):
    console.print(f"[cyan]Running ARP discovery on {network_cidr}...[/cyan]")
    arp = scapy.ARP(pdst=network_cidr)
    ether = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
    packet = ether/arp
    try:
        answered = scapy.srp(packet, timeout=3, verbose=False)[0]
    except Exception as e:
        console.print(f"[yellow]ARP failed: {e}[/yellow]")
        return []
    devices = []
    for _, r in answered:
        devices.append({"ip": r.psrc, "mac": (r.hwsrc or "").upper(), "info": None})
    console.print(f"[green]ARP discovered {len(devices)} devices[/green]")
    return devices

def nmap_discover(network_cidr: str):
    nm = nmap.PortScanner()
    if not shutil.which("nmap"):
        console.print("[yellow]nmap binary not found — falling back to ARP[/yellow]")
        return arp_discover(network_cidr)
    console.print(f"[cyan]Running nmap discovery (-sn) on {network_cidr}...[/cyan]")
    try:
        nm.scan(hosts=network_cidr, arguments="-sn")
        devices = []
        for host in nm.all_hosts():
            mac = ""
            try:
                mac = nm[host]["addresses"].get("mac", "").upper()
            except Exception:
                mac = ""
            devices.append({"ip": host, "mac": mac, "info": nm[host]})
        console.print(f"[green]nmap discovered {len(devices)} hosts[/green]")
        return devices
    except Exception as e:
        console.print(f"[yellow]nmap discovery error: {e} — using ARP[/yellow]")
        return arp_discover(network_cidr)

# ---------------------------
# Per-host nmap wrapper (for deeper enrichment)
# ---------------------------
def nmap_scan_host(ip: str, mode: str = "quick"):
    """Return parsed host object (or None). mode 'deep' uses version/os/vuln scripts."""
    nm = nmap.PortScanner()
    try:
        if mode == "quick":
            args = "-sS -T4 --top-ports 20 -Pn"
        else:
            # deep includes service/version, OS/fingerprinting and vuln scripts
            args = "-sS -sV -O --osscan-guess --top-ports 200 --script vuln -Pn"
        nm.scan(ip, arguments=args, timeout=CONFIG["nmap_timeout"])
        if ip in nm.all_hosts():
            return nm[ip]
        return None
    except Exception as e:
        # nmap may raise on permissions or timeout
        # return None, caller will handle
        return None

# ---------------------------
# Ping helpers (latency + packet loss + ttl)
# ---------------------------
def ping_device(ip: str, count: int = None):
    """Return (avg_ms, loss_percent, ttl) or (None, None, None). Windows-style ping parsing used."""
    if count is None:
        count = CONFIG["ping_count"]
    system = platform.system().lower()
    if system == "windows":
        cmd = ["ping", "-n", str(count), ip]
    else:
        cmd = ["ping", "-c", str(count), ip]
    try:
        out = subprocess.check_output(cmd, stderr=subprocess.DEVNULL, universal_newlines=True, timeout=15)
    except Exception:
        return (None, None, None)
    avg = None
    loss = None
    ttl = None
    # Windows parse
    if system == "windows":
        m_avg = re.search(r"Average = (\d+)ms", out)
        m_loss = re.search(r"Lost = \d+.*,\s+(\d+)% loss", out) or re.search(r"Lost = \d+.*,\s+Lost% = (\d+)%", out)
        m_ttl = re.search(r"TTL=(\d+)", out)
        if m_avg:
            try:
                avg = float(m_avg.group(1))
            except Exception:
                avg = None
        if m_loss:
            try:
                loss = float(m_loss.group(1))
            except Exception:
                loss = None
        if m_ttl:
            try:
                ttl = int(m_ttl.group(1))
            except Exception:
                ttl = None
    else:
        m_avg = re.search(r"rtt [\w/]+ = [\d\.]+/([\d\.]+)/", out)
        m_loss = re.search(r"(\d+)% packet loss", out)
        m_ttl = re.search(r"time=(?:[\d\.]+) ms\s+ttl=(\d+)", out) or re.search(r"ttl=(\d+)", out)
        if m_avg:
            try:
                avg = float(m_avg.group(1))
            except Exception:
                avg = None
        if m_loss:
            try:
                loss = float(m_loss.group(1))
            except Exception:
                loss = None
        if m_ttl:
            try:
                ttl = int(m_ttl.group(1))
            except Exception:
                ttl = None
    return (avg, loss, ttl)

# ---------------------------
# Role & OS inference + confidence scoring
# ---------------------------
def infer_role_and_confidence(vendor: str, os_name: str, open_ports: list, ttl: Optional[int]) -> tuple[str, int]:
    """
    Heuristic role inference using vendor, OS, ports, TTL.
    Returns (role, confidence_percent)
    """
    v = (vendor or "").lower()
    o = (os_name or "").lower()
    ports = set(open_ports or [])
    score = 40  # base

    # strong indicators
    if any(p in ports for p in (554, 8554, 5544)) or "camera" in o or "hikvision" in v or "axis" in v:
        return ("IP Camera", 95)
    if "printer" in v or 9100 in ports:
        return ("Printer", 93)
    if any(k in v for k in ("roku", "amazon", "chromecast", "philips")) or "smarttv" in o or "tv" in o:
        return ("Smart TV / Streaming Device", 90)
    if any(k in v for k in ("apple",)) or "ios" in o or "iphone" in o or "ipad" in o:
        return ("Phone / Tablet (Apple)", 92)
    if any(k in v for k in ("samsung", "xiaomi", "huawei")) or "android" in o:
        return ("Phone / Tablet (Android)", 88)
    if any(k in v for k in ("cisco", "juniper", "netgear", "tp-link", "arris", "eero", "luxul", "ubiquiti")):
        return ("Router / Switch", 92)
    if "windows" in o or any(k in v for k in ("dell", "hp", "lenovo", "microsoft")):
        return ("Laptop / Desktop (Windows)", 85)
    if "mac os" in o or "darwin" in o or any(k in v for k in ("apple")) and "iphone" not in o:
        return ("Mac / macOS", 88)
    if "linux" in o or any(k in v for k in ("raspberry", "ubuntu", "debian", "centos", "red hat", "redhat")):
        # server vs IoT — if ports suggest server
        if any(p in ports for p in (22, 80, 443, 3306, 5432)):
            return ("Server / Linux Host", 90)
        return ("Linux / Embedded", 75)

    # TTL heuristics: many routers reply with TTL high/low? (weak)
    if ttl is not None:
        if ttl <= 64:
            score += 5
        elif ttl > 128:
            score += 3

    # port-based signals
    if 22 in ports and not (80 in ports or 443 in ports):
        return ("SSH Host / Appliance", 80)
    if 80 in ports or 443 in ports:
        return ("Web-Connected Device", 70)

    # fallback
    return ("Generic Device", min(95, score))

def os_confidence_from_nmap(nmap_host):
    """Return (os_guess, confidence). Heuristics: prefer nmap osmatch if present."""
    if not nmap_host:
        return ("Unknown", 0)
    try:
        # python-nmap exposes 'osmatch' as list
        osmatch = nmap_host.get("osmatch", [])
        if osmatch:
            name = osmatch[0].get("name", "Unknown")
            # nmap produces a 'accuracy' field sometimes
            acc = osmatch[0].get("accuracy")
            try:
                conf = int(acc) if acc is not None else 85
            except Exception:
                conf = 85
            return (name, conf)
        # fallback to osclass
        osclass = nmap_host.get("osclass", [])
        if osclass:
            fam = osclass[0].get("osfamily") or osclass[0].get("osgen") or "Unknown"
            conf = osclass[0].get("accuracy") or 70
            try:
                conf = int(conf)
            except Exception:
                conf = 70
            return (fam, conf)
    except Exception:
        pass
    return ("Unknown", 0)

# ---------------------------
# Vulnerability extraction helpers
# ---------------------------
CVE_RE = re.compile(r"(CVE-\d{4}-\d{4,7})", re.IGNORECASE)

def parse_nmap_scripts_for_cves(nmap_host):
    """Extract CVE IDs and short descriptions from nmap hostscript output (if present)."""
    results = []
    # hostscript is usually list of dict { 'id': 'vuln', 'output': '... CVE-...' }
    try:
        hostscript = nmap_host.get("hostscript", []) if nmap_host else []
    except Exception:
        hostscript = []
    for s in hostscript:
        out = (s.get("output") or "")
        # find CVE tokens
        cves = CVE_RE.findall(out)
        if cves:
            for cve in sorted(set(cves)):
                # extract small snippet containing cve
                m = re.search(r".{0,80}"+re.escape(cve)+r".{0,80}", out, re.IGNORECASE)
                snippet = m.group(0).strip() if m else out[:120].strip()
                # form "CVE-xxxx-xxxx - snippet" (normalize newlines safely)
                snippet_clean = snippet.replace("\n", " ").strip()
                readable = f"{cve} - {snippet_clean}"
                results.append(readable)
        else:
            # sometimes script output names a CVE-like description
            if len(out) > 10:
                results.append(out.strip()[:200])
    # also check scripts listed in 'script' keys in services
    try:
        services = nmap_host.get("tcp", {}) if nmap_host else {}
        for port, svc in services.items():
            scripts = svc.get("script", {}) if isinstance(svc.get("script", {}), dict) else svc.get("script", [])
            # script may be dict or list
            if isinstance(scripts, dict):
                for k, v in scripts.items():
                    text = v if isinstance(v, str) else str(v)
                    cves = CVE_RE.findall(text)
                    if cves:
                        for cve in sorted(set(cves)):
                            m = re.search(r".{0,80}"+re.escape(cve)+r".{0,80}", text, re.IGNORECASE)
                            snippet = m.group(0).strip() if m else text[:120].strip()
                            snippet_clean = snippet.replace("\n", " ").strip()
                            results.append(f"{cve} - {snippet_clean}")
                    elif text:
                        results.append(text.strip()[:200])
            elif isinstance(scripts, list):
                for item in scripts:
                    text = item.get("output") if isinstance(item, dict) else str(item)
                    cves = CVE_RE.findall(text)
                    if cves:
                        for cve in sorted(set(cves)):
                            m = re.search(r".{0,80}"+re.escape(cve)+r".{0,80}", text, re.IGNORECASE)
                            snippet = m.group(0).strip() if m else text[:120].strip()
                            snippet_clean = snippet.replace("\n", " ").strip()
                            results.append(f"{cve} - {snippet_clean}")
                    elif text:
                        results.append(text.strip()[:200])
    except Exception:
        pass

    # dedupe & limit
    seen = []
    for r in results:
        if r not in seen:
            seen.append(r)
    return seen[:10]

# ---------------------------
# Service versions summarization
# ---------------------------
def summarize_service_versions(nmap_host):
    """Return short summary string of services/products and versions."""
    if not nmap_host:
        return "None"
    services = []
    try:
        tcp = nmap_host.get("tcp", {}) or {}
        for port_s, info in tcp.items():
            try:
                port = int(port_s)
            except Exception:
                continue
            state = info.get("state", "")
            if state != "open":
                continue
            name = info.get("name") or ""
            product = info.get("product") or ""
            version = info.get("version") or ""
            extr = f"{product} {version}".strip()
            if extr:
                services.append(f"{port}/{name} ({extr})")
            else:
                services.append(f"{port}/{name}")
    except Exception:
        pass
    if not services:
        return "None"
    joined = "; ".join(services)
    if len(joined) > CONFIG["max_service_version_len"]:
        joined = joined[:CONFIG["max_service_version_len"]-3] + "..."
    return joined

# ---------------------------
# Per-device enrichment
# ---------------------------
def enrich_device(device: dict, mode: str = "quick"):
    ip = device.get("ip")
    mac = device.get("mac") or ""
    result = {
        "ip": ip,
        "mac": mac,
        "vendor": "Unknown",
        "vendor_conf": 0,
        "hostname": "",
        "os": "Unknown",
        "os_conf": 0,
        "role": "Generic Device",
        "role_conf": 0,
        "latency_ms": "N/A",
        "packet_loss": "N/A",
        "ttl": None,
        "open_ports": "None",
        "services": "None",
        "vulnerabilities": "None",
        "discovered_at": datetime.utcnow().isoformat() + "Z",
        "last_seen_at": datetime.utcnow().isoformat() + "Z"
    }

    # vendor
    try:
        vendor, vconf = mac_vendor_lookup(mac)
        result["vendor"] = vendor
        result["vendor_conf"] = vconf
    except Exception:
        pass

    # ping
    try:
        avg, loss, ttl = ping_device(ip)
        result["latency_ms"] = f"{avg:.1f} ms" if avg is not None else "N/A"
        result["packet_loss"] = f"{loss:.0f}%" if loss is not None else "N/A"
        result["ttl"] = ttl
    except Exception:
        pass

    # nmap deep/quick
    ndata = None
    try:
        ndata = nmap_scan_host(ip, mode)
    except Exception:
        ndata = None

    # OS guess & confidence
    try:
        os_guess, os_conf = os_confidence_from_nmap(ndata)
        result["os"] = os_guess or "Unknown"
        result["os_conf"] = os_conf or 0
    except Exception:
        pass

    # open ports & service versions
    try:
        sv = summarize_service_versions(ndata)
        result["services"] = sv
        # build open ports list
        open_ports = []
        if ndata:
            tcp = ndata.get("tcp", {}) or {}
            for p, info in tcp.items():
                try:
                    if info.get("state") == "open":
                        open_ports.append(int(p))
                except Exception:
                    continue
        result["open_ports"] = ", ".join(map(str, sorted(open_ports))) if open_ports else "None"
    except Exception:
        pass

    # vulnerabilities / CVEs
    try:
        cves = parse_nmap_scripts_for_cves(ndata)
        if cves:
            result["vulnerabilities"] = "; ".join(cves)
        else:
            # heuristics: if dangerous ports open, flag potential issues
            op = [int(p) for p in (result["open_ports"].split(", ") if result["open_ports"] and result["open_ports"] != "None" else []) if p]
            weak_ports = []
            if 23 in op:
                weak_ports.append("Telnet open (plaintext)")
            if 21 in op:
                weak_ports.append("FTP open (plaintext)")
            if 445 in op:
                weak_ports.append("SMB exposed")
            if weak_ports:
                result["vulnerabilities"] = "; ".join(weak_ports)
    except Exception:
        pass

    # hostname
    try:
        hostname = None
        try:
            hostname = socket.gethostbyaddr(ip)[0]
        except Exception:
            hostname = None
        # netbios fallback (Windows)
        if not hostname:
            try:
                nb = subprocess.check_output(["nbtstat", "-A", ip], universal_newlines=True, stderr=subprocess.DEVNULL, timeout=3)
                m = re.search(r"^\s*([A-Z0-9_\-]+)\s+<00>", nb, re.MULTILINE)
                if m:
                    hostname = m.group(1)
            except Exception:
                hostname = hostname
        result["hostname"] = hostname or ip
    except Exception:
        result["hostname"] = ip

    # infer role with confidence
    try:
        open_ports_list = []
        if result["open_ports"] and result["open_ports"] != "None":
            open_ports_list = [int(p) for p in result["open_ports"].split(",") if p and p.strip().isdigit()]
        role, rconf = infer_role_and_confidence(result["vendor"], result["os"], open_ports_list, result["ttl"])
        result["role"] = role
        result["role_conf"] = rconf
    except Exception:
        result["role"] = "Generic Device"
        result["role_conf"] = 30

    return result

# ---------------------------
# Parallel enrichment wrapper
# ---------------------------
def enrich_devices(devices: list, mode: str):
    enriched = []
    with ThreadPoolExecutor(max_workers=CONFIG["device_thread_workers"]) as ex:
        futures = {ex.submit(enrich_device, d, mode): d for d in devices}
        with Progress(SpinnerColumn(), "[progress.description]{task.description}", BarColumn(), "{task.completed}/{task.total}", TimeRemainingColumn()) as prog:
            task = prog.add_task("Enriching devices", total=len(futures))
            for fut in as_completed(futures):
                try:
                    enriched.append(fut.result())
                except Exception:
                    enriched.append(futures[fut])
                prog.update(task, advance=1)
    return enriched

# ---------------------------
# Export helpers (Excel/CSV/JSON)
# ---------------------------
def save_excel(devices: list, path: str):
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Scan Report"
    headers = [
        "IP", "MAC", "Vendor", "Vendor_Confidence", "Hostname",
        "OS", "OS_Confidence", "Role", "Role_Confidence",
        "Latency_ms", "Packet_Loss", "Open_Ports", "Services",
        "Vulnerabilities", "Discovered_At", "Last_Seen"
    ]
    ws.append(headers)
    for d in devices:
        row = [
            d.get("ip"), d.get("mac"), d.get("vendor"), d.get("vendor_conf"),
            d.get("hostname"), d.get("os"), d.get("os_conf"),
            d.get("role"), d.get("role_conf"),
            d.get("latency_ms"), d.get("packet_loss"),
            d.get("open_ports"), d.get("services"),
            d.get("vulnerabilities"), d.get("discovered_at"), d.get("last_seen_at")
        ]
        ws.append(row)

    # Access Points sheet
    try:
        aps = list_access_points()
        if aps:
            ws_ap = wb.create_sheet("Access Points")
            ws_ap.append(["SSID", "BSSID", "Signal", "Type"])
            ssid_groups = defaultdict(list)
            for ap in aps:
                ssid = ap.get("ssid") or "Unknown"
                ssid_groups[ssid].append(ap)
            for ap in aps:
                ssid = ap.get("ssid") or "Unknown"
                typ = "Mesh/Extender" if len(ssid_groups[ssid]) > 1 else "Primary"
                ws_ap.append([ap.get("ssid"), ap.get("bssid"), ap.get("signal"), typ])
            # If current connection, add
            cur = current_connection()
            if cur:
                ws_ap.append([])
                ws_ap.append(["Current Connection"])
                ws_ap.append(["SSID", cur.get("ssid"), cur.get("bssid"), cur.get("rate"), cur.get("signal")])
    except Exception:
        pass

    wb.save(path)
    console.print(f"[green]✔ Excel saved to {os.path.abspath(path)}[/green]")

def save_csv(devices: list, path: str):
    import csv
    headers = [
        "IP", "MAC", "Vendor", "Vendor_Confidence", "Hostname",
        "OS", "OS_Confidence", "Role", "Role_Confidence",
        "Latency_ms", "Packet_Loss", "Open_Ports", "Services",
        "Vulnerabilities", "Discovered_At", "Last_Seen"
    ]
    with open(path, "w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(headers)
        for d in devices:
            w.writerow([
                d.get("ip"), d.get("mac"), d.get("vendor"), d.get("vendor_conf"),
                d.get("hostname"), d.get("os"), d.get("os_conf"),
                d.get("role"), d.get("role_conf"),
                d.get("latency_ms"), d.get("packet_loss"),
                d.get("open_ports"), d.get("services"),
                d.get("vulnerabilities"), d.get("discovered_at"), d.get("last_seen_at")
            ])
    console.print(f"[green]✔ CSV saved to {os.path.abspath(path)}[/green]")

def save_json(devices: list, path: str):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(devices, f, indent=2)
    console.print(f"[green]✔ JSON saved to {os.path.abspath(path)}[/green]")

# ---------------------------
# Wi-Fi/AP helpers (Windows-focused)
# ---------------------------
def list_access_points():
    system = platform.system().lower()
    aps = []
    try:
        if system == "windows":
            out = subprocess.check_output("netsh wlan show networks mode=bssid", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL)
            ssid = None
            bssid = None
            signal = None
            for line in out.splitlines():
                if "SSID" in line and "BSSID" not in line:
                    ssid = line.split(":", 1)[1].strip()
                elif "BSSID" in line:
                    bssid = line.split(":", 1)[1].strip()
                elif "Signal" in line:
                    signal = line.split(":", 1)[1].strip()
                    if ssid and bssid:
                        aps.append({"ssid": ssid, "bssid": bssid, "signal": signal})
        else:
            out = subprocess.check_output("nmcli -t -f SSID,BSSID,SIGNAL dev wifi", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL)
            for line in out.strip().split("\n"):
                parts = line.split(":")
                if len(parts) >= 3:
                    aps.append({"ssid": parts[0], "bssid": parts[1], "signal": parts[2]})
    except Exception:
        pass
    return aps

def current_connection():
    system = platform.system().lower()
    if system == "windows":
        try:
            out = subprocess.check_output("netsh wlan show interfaces", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL)
            ssid = re.search(r"SSID\s*:\s(.+)", out)
            bssid = re.search(r"BSSID\s*:\s(.+)", out)
            rate = re.search(r"Receive rate \(Mbps\)\s*:\s(.+)", out)
            signal = re.search(r"Signal\s*:\s(.+)", out)
            return {
                "ssid": ssid.group(1).strip() if ssid else None,
                "bssid": bssid.group(1).strip() if bssid else None,
                "rate": rate.group(1).strip() if rate else None,
                "signal": signal.group(1).strip() if signal else None
            }
        except Exception:
            return None
    else:
        try:
            out = subprocess.check_output("iw dev wlan0 link", shell=True, universal_newlines=True, stderr=subprocess.DEVNULL)
            ssid = re.search(r"SSID: (.+)", out)
            bssid = re.search(r"Connected to (.+)", out)
            rate = re.search(r"tx bitrate: (.+)", out)
            return {
                "ssid": ssid.group(1).strip() if ssid else None,
                "bssid": bssid.group(1).strip() if bssid else None,
                "rate": rate.group(1).strip() if rate else None
            }
        except Exception:
            return None

# ---------------------------
# Main: Orchestration
# ---------------------------
def main():
    console.print("[bold cyan]ZeroTrace Enhanced Scanner — v4[/bold cyan]")
    admin = is_admin()
    if admin:
        console.print("[green]✔ Running with administrator privileges[/green]")
    else:
        console.print("[yellow]⚠ Not running as administrator — some scans (OS detection / vuln scripts) may be limited.[/yellow]")

    load_oui_file()

    conn_type = get_connection_type()
    ssid = get_wifi_ssid() if conn_type == "Wi-Fi" else None
    console.print(f"[blue]Connection type:[/] {conn_type}")
    if ssid:
        console.print(f"[blue]Connected SSID:[/] {ssid}")

    # choose quick/deep/both
    mode = console.input("[cyan]Scan mode ([b]quick[/b]/[b]deep[/b]/[b]both[/b]) [quick]: ").strip().lower() or "quick"
    while mode not in ("quick", "deep", "both"):
        mode = console.input("[cyan]Choose 'quick', 'deep' or 'both': ").strip().lower()

    # choose discovery
    disc = console.input("[cyan]Discovery method ([b]nmap[/b]/[b]arp[/b]/[b]both[/b]) [nmap]: ").strip().lower() or "nmap"
    while disc not in ("nmap", "arp", "both"):
        disc = console.input("[cyan]Choose 'nmap', 'arp' or 'both': ").strip().lower()

    # choose export type (default excel)
    export_choice = console.input("[cyan]Export format ([b]excel[/b]/[b]csv[/b]/[b]json) [excel]: ").strip().lower() or "excel"
    while export_choice not in ("excel", "csv", "json"):
        export_choice = console.input("[cyan]Choose 'excel', 'csv' or 'json': ").strip().lower()

    local_ip = get_local_ip()
    if not local_ip:
        console.print("[red]Could not determine local IP address — aborting.[/red]")
        return
    network_cidr = str(ipaddress.ip_network(f"{local_ip}/24", strict=False))
    console.print(f"[blue]Scanning subnet: {network_cidr}[/blue]")

    # discovery phase
    discovered = []
    if disc == "arp":
        discovered = arp_discover(network_cidr)
    elif disc == "nmap":
        discovered = nmap_discover(network_cidr)
    else:
        arp_list = arp_discover(network_cidr)
        nmap_list = nmap_discover(network_cidr)
        ipmap = {}
        for d in arp_list:
            ipmap[d["ip"]] = d
        for n in nmap_list:
            if n["ip"] not in ipmap:
                ipmap[n["ip"]] = n
            else:
                # prefer mac if missing
                if not ipmap[n["ip"]].get("mac") and n.get("mac"):
                    ipmap[n["ip"]]["mac"] = n.get("mac")
        discovered = list(ipmap.values())

    if not discovered:
        console.print("[red]No devices discovered.[/red]")
        return

    # scanning mode: if 'both', do quick discovery then deep enrichment (we pass mode accordingly)
    nmap_mode = "deep" if mode in ("deep", "both") else "quick"

    console.print(f"[cyan]Discovered {len(discovered)} devices — enriching (mode={nmap_mode})...[/cyan]")

    devices_enriched = enrich_devices(discovered, nmap_mode)

    # timestamp last seen/update
    ts = datetime.utcnow().isoformat() + "Z"
    for d in devices_enriched:
        d["last_seen_at"] = ts

    # Show table summary
    headers = ["IP", "Name", "Vendor (conf)", "OS (conf)", "Role (conf)", "Latency", "Packet Loss", "Open Ports", "Vulns"]
    tbl = Table(title="ZeroTrace Network Summary (preview)", show_lines=False)
    for h in headers:
        tbl.add_column(h, overflow="fold")
    for d in devices_enriched:
        vendor_conf = f"{d.get('vendor')} ({d.get('vendor_conf',0)}%)"
        os_conf = f"{d.get('os')} ({d.get('os_conf',0)}%)"
        role_conf = f"{d.get('role')} ({d.get('role_conf',0)}%)"
        tbl.add_row(
            str(d.get("ip") or ""),
            str(d.get("hostname") or ""),
            vendor_conf,
            os_conf,
            role_conf,
            str(d.get("latency_ms") or ""),
            str(d.get("packet_loss") or ""),
            str(d.get("open_ports") or ""),
            str(d.get("vulnerabilities") or "")
        )
    console.print(tbl)

    # Save report (default Excel in same folder)
    outname = CONFIG["excel_output"]
    if export_choice == "excel":
        save_excel(devices_enriched, outname)
    elif export_choice == "csv":
        outcsv = os.path.splitext(outname)[0] + ".csv"
        save_csv(devices_enriched, outcsv)
    else:
        outjson = os.path.splitext(outname)[0] + ".json"
        save_json(devices_enriched, outjson)

    console.print("[green]Done.[/green]")

if __name__ == "__main__":
    main()
